!SESSION 2021-12-22 11:04:25.830 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\Users\sakshaik\practice\.metadata\.bak_0.log
Created Time: 2022-01-12 15:57:55.304

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-12 15:57:55.306
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-12 15:57:55.309
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-17 14:28:02.546
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.hackerrank;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

public class HackerRankTest {

	public static void main(String[] args) {

		// Sock Merchant
		System.out.println("Sock Merchant");
		List<Integer> ar = Arrays.asList(1, 2, 1, 2, 1, 3, 2);
		System.out.println(HackerRankTest.sockMerchant(ar.size(), ar));

		// Valley Test
		System.out.println("Valley Test");
		String path = "UDDDUDUU";
		System.out.println(HackerRankTest.countingValleys(path.length(), path));

		// Jumping in the clouds
		System.out.println("Jumping in the clouds");
		List<Integer> cloud = Arrays.asList(0, 1, 0, 0, 0, 1, 0);
		System.out.println(HackerRankTest.jumpingOnClouds(cloud));

		// Repeated String
		System.out.println("Repeated String");
		System.out.println(HackerRankTest.repeatedString("abcac", 10));
		System.out.println(HackerRankTest.repeatedString("dcd", 10));
		System.out.println(HackerRankTest.repeatedString("a", 10));

		// Hourglass sum
		System.out.println("Hourglass sum");
		int[][] array = { { -9, -9, -9, 1, 1, 1 }, { 0, -9, 0, 4, 3, 2 }, { -9, -9, -9, 1, 2, 3 }, { 0, 0, 8, 6, 6, 0 },
				{ 0, 0, 0, -2, 0, 0 }, { 0, 0, 1, 2, 4, 0 } };
		List<List<Integer>> list = new ArrayList<List<Integer>>();
		for (int i = 0; i < array.length; i++) {
			List<Integer> data = new ArrayList<Integer>();
			for (int j = 0; j < array[0].length; j++) {
				data.add(array[i][j]);
			}
			list.add(data);
		}
		System.out.println(list);
		System.out.println(HackerRankTest.hourglassSum(list));

		// Left Rotate array
		System.out.println("Left Rotate Array");
		List<Integer> nums = Arrays.asList(1, 3, 2, 4, 5, 6, 7);
		System.out.println(nums);
		System.out.println(HackerRankTest.rotLeft(nums, 3));

		// Mininum Bribes
		System.out.println("Minimum Bribes");
		List<Integer> position = new ArrayList<Integer>();
		int[] pos = { 1, 2, 5, 3, 7, 8, 6, 4 };
		for (int i = 0; i < pos.length; i++) {
			position.add(pos[i]);
		}
		HackerRankTest.minimumBribes(position);

		// Minimum swaps
		System.out.println("Minimum Swaps");
		System.out.println(HackerRankTest.minimumSwaps(pos));

		// Array manipulation
		List<Integer> query1 = Arrays.asList(1, 2, 100);
		List<Integer> query2 = Arrays.asList(2, 5, 100);
		List<Integer> query3 = Arrays.asList(3, 4, 100);
		List<List<Integer>> queries = new ArrayList<List<Integer>>();
		queries.add(query1);
		queries.add(query2);
		queries.add(query3);
		System.out.println("Array manipulation");
		System.out.println(HackerRankTest.arrayManipulation(5, queries));

		// Hashtable : Ransom Note
		System.out.println("Hashtable : Ransom Note");
		List<String> magazine = Arrays.asList("give", "me", "one", "grand", "today", "night");
		List<String> note = Arrays.asList("give", "one", "grand", "today");
		HackerRankTest.checkMagazine(magazine, note);
		magazine = Arrays.asList("two", "times", "three", "is", "not", "four");
		note = Arrays.asList("two", "times", "two", "is", "four");
		HackerRankTest.checkMagazine(magazine, note);

		// Two Strings have common substring
		System.out.println("Two String have common substring");
		System.out.println(HackerRankTest.twoStrings("abc", "ab"));
		System.out.println(HackerRankTest.twoStrings("abc", "def"));

		// Anagram list of a string
		System.out.println("Anagram list of a string");
		System.out.println(HackerRankTest.sherlockAndAnagrams("abba"));

		// Count triplets of geometric progression
		System.out.println("Count triplets of geometric progression");
		List<Long> values = Arrays.asList(1L, 3L, 9L, 9L, 27L, 81L);
		System.out.println(HackerRankTest.countTriplets(values, 3));

		// Frequency query

		// Bubble sort
		System.out.println("Bubble Sort");
		List<Integer> unsorted = Arrays.asList(3, 2, 1);
		HackerRankTest.countSwaps(unsorted);

		// Activity notification
		System.out.println("Activity notification");
		List<Integer> txns = Arrays.asList(10, 20, 30, 40, 50);
		System.out.println(HackerRankTest.activityNotifications(txns, 3));

		// Array Sort Swap Count
		System.out.println("Array Sort Swap Count");
		List<Integer> counts = Arrays.asList(2, 1, 3, 1, 2);
		System.out.println(HackerRankTest.countInversions(counts));
		System.out.println(counts);

		// Remove characters to make anagram
		System.out.println("Remove characters to make anagram");
		System.out.println(HackerRankTest.makeAnagram("fcrxzwscanmligyxyvym", "jxwtrhvujlmrpdoqbisbwhmgpmeoke"));

		// Alternating characters
		System.out.println("Remove characters to make string alternating");
		System.out.println(HackerRankTest.alternatingCharacters("AAABBB"));

		// Sherlock and the valid string
		System.out.println("Sherlock and the valid string");
		System.out.println(HackerRankTest.isValid("aabbccddeefghi"));
		System.out.println(HackerRankTest.isValid("abcc"));
		System.out.println(HackerRankTest.isValid("abccc"));

		// Special Substring count
		System.out.println("Special Substring count");
		String s = "mnonopoo";
		System.out.println(HackerRankTest.substrCount(s.length(), s));
		s = "abcbaba";
		System.out.println(HackerRankTest.substrCount(s.length(), s));

		// Common Child Algorithm
		System.out.println("Common Child Algorithm");
		System.out.println(HackerRankTest.commonChild("ABCD", "ABDC"));
		System.out.println(HackerRankTest.commonChild("SHINCHAN", "NOHARAAA"));
		System.out.println(HackerRankTest.commonChild("ABCDEF", "FBDAMN"));
		System.out.println(HackerRankTest.commonChild("AA", "BB"));

		// Minimum absolute difference
		System.out.println("Minimum absolute difference");
		List<Integer> min = Arrays.asList(3, -7, 0);
		System.out.println(HackerRankTest.minimumAbsoluteDifference(min));
		min = Arrays.asList(-59, -36, -13, 1, -53, -92, -2, -96, -54, 75);
		System.out.println(HackerRankTest.minimumAbsoluteDifference(min));

		// Luck Balance
		System.out.println("Luck Balance");
		List<List<Integer>> contests = Arrays.asList(Arrays.asList(5, 1), Arrays.asList(1, 1), Arrays.asList(4, 0));
		System.out.println(HackerRankTest.luckBalance(2, contests));
		System.out.println(HackerRankTest.luckBalance(1, contests));

		// Minimum cost for greedy florist
		System.out.println("Minimum cost for greedy florist");
		int[] flowers = { 1, 3, 5, 7, 9 };
		System.out.println(HackerRankTest.getMinimumCost(3, flowers));
		int[] flowers2 = { 2, 5, 6 };
		System.out.println(HackerRankTest.getMinimumCost(3, flowers2));
		System.out.println(HackerRankTest.getMinimumCost(2, flowers2));

		// Mininum Max-Min difference of a subarray
		System.out.println("Mininum Max-Min difference of a subarray");
		List<Integer> minMax = Arrays.asList(1, 4, 7, 2);
		System.out.println(HackerRankTest.maxMin(2, minMax));
		minMax = Arrays.asList(10, 100, 300, 200, 1000, 20, 30);
		System.out.println(HackerRankTest.maxMin(3, minMax));
		minMax = Arrays.asList(1, 2, 3, 4, 10, 20, 30, 40, 100, 200);
		System.out.println(HackerRankTest.maxMin(4, minMax));
		minMax = Arrays.asList(1, 2, 1, 2, 1);
		System.out.println(HackerRankTest.maxMin(2, minMax));

		// Reverse Shuffle Merge
		System.out.println("String - Reverse Shuffle Merge");
		System.out.println(HackerRankTest.reverseShuffleMerge("aeiouuoiea"));
		System.out.println(HackerRankTest.reverseShuffleMerge("abcdefgabcdefg"));
		System.out.println(HackerRankTest.reverseShuffleMerge("eggegg"));

		// What 2 flavors for a given value
		System.out.println("What 2 flavors for a given value");
		List<Integer> flavors = Arrays.asList(2, 1, 3, 5, 6);
		HackerRankTest.whatFlavors(flavors, 5);

		// Minimum pass to create candies
		System.out.println("Minimum pass to create candies");
		System.out.println(HackerRankTest.minimumPasses(1L, 2L, 1L, 60L));

		// Max Subarray Sum
		System.out.println("Max Subarray Sum");
		int[] a = { -2, 1, 3, -4, 5 };
		System.out.println(HackerRankTest.maxSubsetSum(a));

		// Abbreviation of two strings
		System.out.println("Abbreviation of two strings");
		System.out.println(HackerRankTest.abbreviation("AbcDE", "ABDE"));
		System.out.println(HackerRankTest.abbreviation("daBcd", "ABC"));
		System.out.println(HackerRankTest.abbreviation("AbcDE", "AFDE"));
	}

	public static int sockMerchant(int n, List<Integer> ar) {
		HashMap<Integer, Integer> count = new HashMap<>();
		for (Integer color : ar) {
			if (count.containsKey(color)) {
				int newCount = count.get(color) + 1;
				count.put(color, newCount);
			} else {
				count.put(color, 1);
			}
		}
		int result = 0;
		for (Integer color : count.keySet()) {
			result += count.get(color) / 2;
		}
		return result;
	}

	public static int countingValleys(int steps, String path) {
		int v = 0;
		int lvl = 0;
		for (char c : path.toCharArray()) {
			if (c == 'U')
				++lvl;
			if (c == 'D')
				--lvl;

			if (lvl == 0 && c == 'U')
				++v;
		}
		return v;
	}

	public static int jumpingOnClouds(List<Integer> c) {
		int count = -1;
		for (int i = 0; i < c.size(); i++, count++) {
			if (i < c.size() - 2 && c.get(i + 2) == 0)
				i++;
		}
		return count;
	}

	public static long repeatedString(String s, long n) {
		char[] c = s.toLowerCase().toCharArray();
		int l = c.length;
		if (l == 1 && c[0] == 'a') {
			return n;
		}
		int count = 0;
		for (int i = 0; i < l; i++) {
			if (c[i] == 'a') {
				count++;
			}
		}
		if (count == 0) {
			return count;
		}
		if (n % l == 0) {
			return (n / l) * count;
		} else {
			long repetition = (n / l) * count;
			long remainder = n % l;
			int temp = 0;
			for (int i = 0; i < remainder; i++) {
				if (c[i] == 'a') {
					temp++;
				}
			}
			return repetition + temp;
		}
	}

	public static int hourglassSum(List<List<Integer>> arr) {
		int result = Integer.MIN_VALUE;
		int rows = arr.size();
		int columns = arr.get(0).size();
		int i = 0, j = 0;
		while (i < rows - 2) {
			j = 0;
			while (j < columns - 2) {
				int row1 = arr.get(i).get(j) + arr.get(i).get(j + 1) + arr.get(i).get(j + 2);
				int row2 = arr.get(i + 1).get(j + 1);
				int row3 = arr.get(i + 2).get(j) + arr.get(i + 2).get(j + 1) + arr.get(i + 2).get(j + 2);
				result = Math.max(result, (row1 + row2 + row3));
				j++;
			}
			i++;
		}
		return result;
	}

	public static List<Integer> rotLeft(List<Integer> a, int d) {
		int size = a.size();
		d = (d % size) * -1;
		if (a.size() == 0) {
			return a;
		} else if (d < 0) {
			d += size;
		}
		if (d == 0) {
			return a;
		}

		for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
			Integer displaced = a.get(cycleStart);
			int i = cycleStart;
			do {
				i += d;
				if (i >= size)
					i -= size;
				displaced = a.set(i, displaced);
				nMoved++;
			} while (i != cycleStart);
		}
		return a;
	}

	public static void minimumBribes(List<Integer> q) {
		int bribe = 0;
		boolean chaotic = false;
		int n = q.size();
		for (int i = 0; i < n; i++) {
			if (q.get(i) - (i + 1) > 2) {
				chaotic = true;
				break;
			}
			for (int j = Math.max(0, q.get(i) - 2); j < i; j++) {
				if (q.get(j) > q.get(i))
					bribe++;
			}
		}
		if (chaotic)
			System.out.println("Too chaotic");
		else
			System.out.println(bribe);
	}

	static int minimumSwaps(int[] arr) {
		int swap = 0;
		for (int i = 0; i < arr.length; i++) {
			if (i + 1 != arr[i]) {
				int t = i;
				while (arr[t] != i + 1) {
					t++;
				}
				int temp = arr[t];
				arr[t] = arr[i];
				arr[i] = temp;
				swap++;
			}
		}
		return swap;
	}

	public static long arrayManipulation(int n, List<List<Integer>> queries) {
		long[] start = new long[n + 1];
		long[] end = new long[n + 1];
		long max = -1L;
		long sum = 0L;
		for (int i = 0; i < queries.size(); i++) {
			int a = queries.get(i).get(0);
			int b = queries.get(i).get(1);
			long k = queries.get(i).get(2);
			start[a] += k;
			end[b] += k;
		}
		for (int i = 1; i < n + 1; i++) {
			sum += start[i];
			if (sum > max) {
				max = sum;
			}
			sum -= end[i];
		}
		return max;
	}

	public static void checkMagazine(List<String> magazine, List<String> note) {
		if (note == null || note.isEmpty() || magazine == null || magazine.isEmpty()
				|| (note.size() > magazine.size())) {
			System.out.println("No");
			return;
		}

		HashMap<String, Integer> count = new HashMap<String, Integer>();

		for (String key : magazine) {
			if (count.containsKey(key)) {
				count.put(key, count.get(key) + 1);
			} else {
				count.put(key, 1);
			}
		}

		for (String noteValue : note) {
			if (count.containsKey(noteValue)) {
				count.put(noteValue, count.get(noteValue) - 1);
				if (count.get(noteValue) < 0) {
					System.out.println("No");
					return;
				}
			} else {
				System.out.println("No");
				return;
			}
		}
		System.out.println("Yes");
	}

	public static String twoStrings(String s1, String s2) {
		Set<Character> one = new HashSet<Character>();
		Set<Character> two = new HashSet<Character>();
		for (Character c1 : s1.toCharArray()) {
			one.add(c1);
		}
		for (Character c2 : s2.toCharArray()) {
			two.add(c2);
		}

		one.retainAll(two);
		if (!one.isEmpty()) {
			return "YES";
		}
		return "NO";
	}

	public static int sherlockAndAnagrams(String s) {
		int result = 0;
		Map<String, Integer> count = new HashMap<String, Integer>();
		for (int i = 0; i < s.length(); i++) {
			for (int j = i; j < s.length(); j++) {
				char[] array = s.substring(i, j + 1).toCharArray();
				Arrays.sort(array);
				String sub = new String(array);
				System.out.println(sub);
				if (count.containsKey(sub)) {
					count.put(sub, count.get(sub) + 1);
				} else {
					count.put(sub, 1);
				}
			}
		}
		for (String key : count.keySet()) {
			int v = count.get(key);
			result += (v * (v - 1)) / 2;
		}
		return result;
	}

	static long countTriplets(List<Long> arr, long r) {
		Map<Long, Long> rightMap = getOccurenceMap(arr);
		Map<Long, Long> leftMap = new HashMap<>();
		long numberOfGeometricPairs = 0;

		for (long val : arr) {
			long countLeft = 0;
			long countRight = 0;
			long lhs = 0;
			long rhs = val * r;
			if (val % r == 0) {
				lhs = val / r;
			}
			Long occurence = rightMap.get(val);
			rightMap.put(val, occurence - 1L);

			if (rightMap.containsKey(rhs)) {
				countRight = rightMap.get(rhs);
			}
			if (leftMap.containsKey(lhs)) {
				countLeft = leftMap.get(lhs);
			}
			numberOfGeometricPairs += countLeft * countRight;
			insertIntoMap(leftMap, val);
		}
		return numberOfGeometricPairs;
	}

	private static Map<Long, Long> getOccurenceMap(List<Long> test) {
		Map<Long, Long> occurenceMap = new HashMap<>();
		for (long val : test) {
			insertIntoMap(occurenceMap, val);
		}
		return occurenceMap;
	}

	private static void insertIntoMap(Map<Long, Long> occurenceMap, Long val) {
		if (!occurenceMap.containsKey(val)) {
			occurenceMap.put(val, 1L);
		} else {
			Long occurence = occurenceMap.get(val);
			occurenceMap.put(val, occurence + 1L);
		}
	}

	static List<Integer> freqQuery(List<List<Integer>> queries) {
		List<Integer> ans = new ArrayList<>();
		Map<Integer, Integer> map = new HashMap<>();
		int maxFr = 0;
		for (List<Integer> ops : queries) {
			int op = ops.get(0);
			int data = ops.get(1);
			Integer v = map.get(data) == null ? 0 : map.get(data);
			if (op == 1) {
				map.put(data, ++v);
				maxFr = Math.max(maxFr, v);
			} else if (op == 2) {
				if (v > 0) {
					map.put(data, --v);
				}
			} else {
				if (data <= maxFr && map.containsValue(data))
					ans.add(1);
				else
					ans.add(0);
			}
		}
		return ans;
	}

	public static void countSwaps(List<Integer> a) {
		int n = a.size();
		int swapCount = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n - 1; j++) {
				if (a.get(j) > a.get(j + 1)) {
					swap(a, j, j + 1);
					swapCount++;
				}
			}
		}
		System.out.println("Array is sorted in " + swapCount + " swaps.");
		System.out.println("First Element: " + a.get(0));
		System.out.println("Last Element: " + a.get(n - 1));
	}

	private static void swap(List<Integer> a, int n, int m) {
		int temp = a.get(n);
		a.set(n, a.get(m));
		a.set(m, temp);
	}

	public static int maximumToys(List<Integer> prices, int k) {
		int pl = prices.size();
		int total = prices.stream().reduce(Integer::sum).get();
		if (k >= total)
			return pl;

		prices.sort(Comparator.reverseOrder());
		int reducedPrice = 0;
		for (int i = 0; i < pl; i++) {
			reducedPrice += prices.get(i);
			if (k >= total - reducedPrice) {
				return (pl - i - 1);
			}
		}

		return 0;
	}

	public static int activityNotificationsTemp(List<Integer> expenditure, int d) {
		int size = expenditure.size();
		int notifications = 0;
		if (size <= d) {
			return notifications;
		}

		for (int i = 0; i < size - d; i++) {
			int mean = expenditure.subList(i, d + i).stream().reduce(0, Integer::sum) / d;
			if ((mean * 2) > expenditure.get(d + i)) {
				notifications++;
			}
		}
		return notifications;
	}

	static int activityNotifications(List<Integer> expenditure, int d) {

		int notificationCount = 0;
		int[] data = new int[201];

		for (int i = 0; i < d; i++) {
			data[expenditure.get(i)]++;
		}

		for (int i = d; i < expenditure.size(); i++) {
			double median = getMedian(d, data);
			if (expenditure.get(i) >= 2 * median) {
				notificationCount++;

			}
			data[expenditure.get(i)]++;
			data[expenditure.get(i - d)]--;
		}
		return notificationCount;
	}

	private static double getMedian(int d, int[] data) {
		double median = 0;
		if (d % 2 == 0) {
			Integer m1 = null;
			Integer m2 = null;
			int count = 0;
			for (int j = 0; j < data.length; j++) {
				count += data[j];
				if (m1 == null && count >= d / 2) {
					m1 = j;
				}
				if (m2 == null && count >= d / 2 + 1) {
					m2 = j;
					break;
				}
			}
			median = (m1 + m2) / 2.0;
		} else {
			int count = 0;
			for (int j = 0; j < data.length; j++) {
				count += data[j];
				if (count > d / 2) {
					median = j;
					break;
				}
			}
		}
		return median;
	}

	public static long countInversions(List<Integer> arr) {
		long swapCount = 0;
		int[] helper = new int[arr.size()];
		return mergeSort(arr, 0, arr.size() - 1, helper, swapCount);
	}

	private static long mergeSort(List<Integer> arr, int l, int r, int[] helper, long swapCount) {
		if (l < r) {
			int m = (l + r) / 2;
			swapCount = mergeSort(arr, l, m, helper, swapCount) + mergeSort(arr, m + 1, r, helper, swapCount)
					+ merge(arr, l, m, r, helper, swapCount);
		}
		return swapCount;
	}

	private static long merge(List<Integer> arr, int l, int m, int r, int[] helper, long swapCount) {
		for (int i = l; i <= r; i++) {
			helper[i] = arr.get(i);
		}

		int curr = l;
		int left = l;
		int right = m + 1;

		while (left <= m && right <= r) {
			if (helper[left] <= helper[right]) {
				arr.set(curr++, helper[left++]);
			} else {
				swapCount += m + 1 - left;
				arr.set(curr++, helper[right++]);
			}
		}

		while (left <= m) {
			arr.set(curr++, helper[left++]);
		}
		return swapCount;
	}

	public static int makeAnagram(String a, String b) {
		int cArr[] = new int[26];
		for (int i = 0; i < a.length(); i++)
			cArr[a.charAt(i) - 97]++;
		for (int i = 0; i < b.length(); i++)
			cArr[b.charAt(i) - 97]--;
		int count = 0;
		for (int i = 0; i < 26; i++)
			count += Math.abs(cArr[i]);
		return count;
	}

	public static int alternatingCharacters(String s) {
		int count = 0;
		char lastItem = 0;

		for (char item : s.toCharArray()) {
			if (lastItem == item) {
				count++;
			}
			lastItem = item;
		}
		return count;
	}

	public static String isValid(String s) {
		final String YES = "YES";
		final String NO = "NO";
		if (s.isEmpty()) {
			return NO;
		} else if (s.length() <= 3) {
			return YES;
		}
		int cArr[] = new int[26];
		for (int i = 0; i < s.length(); i++)
			cArr[s.charAt(i) - 97]++;
		Arrays.sort(cArr);
		int i = 0;
		while (cArr[i] == 0) {
			i++;
		}
		int min = cArr[i];
		int max = cArr[25];

		if (min == max) {
			return YES;
		} else if ((max - min == 1) && (max > cArr[24]) || (min == 1) && (cArr[i + 1] == max)) {
			return YES;
		}
		return NO;
	}

	static long substrCount(int n, String s) {
		long res = n;
		for (int i = 0; i < n; i++) {
			boolean isAfterMedian = false;
			int beforeMedian = 1;
			char current = s.charAt(i);
			for (int j = i + 1; j < n; j++) {
				if (!isAfterMedian) {
					if (s.charAt(j) == current) {
						res++;
						beforeMedian++;
					}
					if (s.charAt(j) != current) {
						isAfterMedian = true;
					}
					;
				} else {
					if (s.charAt(j) == current && beforeMedian > 0) {
						beforeMedian--;
						if (beforeMedian == 0)
							res++;
					} else {
						break;
					}
				}
			}
		}
		return res;
	}

	public static int commonChild(String s1, String s2) {
		char[] s1_array = s1.toUpperCase().toCharArray();
		char[] s2_array = s2.toUpperCase().toCharArray();
		int[] count = new int[s1.length() + 1];

		for (int i = 1; i <= s1.length(); i++) {
			int prev = 0;
			for (int j = 1; j <= s2.length(); j++) {
				int temp = count[j];
				if (s1_array[i - 1] == s2_array[j - 1]) {
					count[j] = prev + 1;
				} else {
					count[j] = Math.max(count[j], count[j - 1]);
				}
				prev = temp;
			}
		}
		return count[s1.length()];
	}

	public static int minimumAbsoluteDifference(List<Integer> arr) {
		int[] intArr = arr.stream().sorted().mapToInt(Integer::intValue).toArray();
		int minAbsDiff = Integer.MAX_VALUE;
		for (int i = 0; i < intArr.length - 1; i++) {
			minAbsDiff = Math.min(minAbsDiff, Math.abs(intArr[i] - intArr[i + 1]));
		}
		return minAbsDiff;
	}

	public static int luckBalance(int k, List<List<Integer>> contests) {
		int size = contests.size();
		int loseCount = 0;
		int luckCount = 0;
		Collections.sort(contests, new Comparator<List<Integer>>() {
			@Override
			public int compare(List<Integer> o1, List<Integer> o2) {
				return o2.get(0).compareTo(o1.get(0));
			}
		});

		for (int i = 0; i < size; i++) {
			if (contests.get(i).get(1) == 1) {
				if (loseCount < k) {
					luckCount += contests.get(i).get(0);
					loseCount++;
				} else {
					luckCount -= contests.get(i).get(0);
				}
			} else {
				luckCount += contests.get(i).get(0);
			}
		}
		return luckCount;
	}

	static int getMinimumCost(int k, int[] c) {
		Arrays.sort(c);
		int i = c.length - 1;
		int bought = 0;
		int total = 0;
		// start backwards from the most expensive flower, stop when there is no more
		// flowers left
		while (i >= 0) {
			// Calculate total
			// increment bought by 1 when everyone in the group has bought equal number of
			// flowers
			for (int j = 0; j < k && i >= 0; j++) {
				total += (1 + bought) * c[i];
				i--;
			}
			bought++;
		}
		return total;
	}

	public static int maxMin(int k, List<Integer> arr) {
		int[] a = arr.stream().sorted().mapToInt(x -> x).toArray();
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < a.length - k + 1; i++) {
			min = Math.min(min, a[i + k - 1] - a[i]);
		}
		return min;
	}

	public static String reverseShuffleMerge(String s) {
		int[] count = new int[26], used = new int[26], rem = new int[26];
		StringBuilder sb = new StringBuilder();

		for (int i = 0; i < s.length(); i++) {
			count[s.charAt(i) - 'a']++;
		}
		for (int i = 0; i < count.length; i++) {
			rem[i] = count[i];
		}

		for (int i = s.length() - 1; i >= 0; i--) {
			char c = s.charAt(i);
			if (sb.length() == 0) {
				sb.append(c);
				used[c - 'a']++;
			} else {
				if (2 * used[c - 'a'] == count[c - 'a']) {
					rem[c - 'a']--;
					continue;
				}

				while (sb.length() > 0) {
					char last = sb.charAt(sb.length() - 1);
					if (c < last && 2 * (rem[last - 'a'] + used[last - 'a']) > count[last - 'a']) {
						used[last - 'a']--;
						sb.deleteCharAt(sb.length() - 1);
					} else {
						break;
					}
				}

				sb.append(c);
				used[c - 'a']++;
			}
			rem[c - 'a']--;
		}
		return sb.toString();
	}

	public static void whatFlavors(List<Integer> cost, int money) {
		Map<Integer, Integer> hash = new HashMap<Integer, Integer>();

		int[] res = new int[2];

		for (int i = 0; i < cost.size(); i++) {
			hash.put(cost.get(i), i);
		}

		for (int i = 0; i < cost.size(); i++) {
			int k = money - cost.get(i);
			if (hash.containsKey(k) && hash.get(k) != i) {
				res[0] = i + 1;
				res[1] = hash.get(k) + 1;
				break;
			}
		}

		System.out.printf("%d %d%n", res[0], res[1]);
	}

	public static int pairs(int k, List<Integer> arr) {
		int count;
		HashSet<Integer> set = new HashSet<>(arr);
		count = (int) arr.stream().filter(number -> set.contains(number + k)).count();
		return count;
	}

	static long triplets(int[] a, int[] b, int[] c) {

		long count = 0;

		a = Arrays.stream(a).sorted().distinct().toArray();
		b = Arrays.stream(b).sorted().distinct().toArray();
		c = Arrays.stream(c).sorted().distinct().toArray();

		for (int i = 0; i < b.length; i++) {
			int c1 = getIndex(a, b[i]) + 1;
			int c2 = getIndex(c, b[i]) + 1;
			if (c1 == -1 || c2 == -1)
				continue;
			count += (long) c1 * (long) c2;
		}
		return count;
	}

	public static int getIndex(int[] arr, int e) {
		int index = -1;
		int l = 0, r = arr.length - 1;
		while (l <= r) {
			int mid = (l + r) / 2;
			if (arr[mid] <= e) {
				if (arr[mid] == e) {
					index = mid;
					break;
				}
				index = mid;
				l = mid + 1;
			} else
				r = mid - 1;
		}
		return index;
	}

	static long minTime(long[] machines, long goal) {
		Arrays.sort(machines);
		long max = (machines[machines.length - 1]) * goal;
		long min = 0;
		long result = -1;
		while (max > min) {
			long midValue = (max + min) / 2;
			long unit = 0;
			for (long machine : machines) {
				unit += midValue / machine;
			}
			if (unit < goal) {
				min = midValue + 1;
				result = midValue + 1;
			} else {
				max = midValue;
				result = midValue;
			}
		}
		return result;
	}

	public static long maximumSum(List<Long> a, long m) {
		long max = 0, curr = 0;
		TreeSet<Long> t = new TreeSet<>();
		for (int i = 0; i < a.size(); i++) {
			curr = (curr + a.get(i) % m) % m;
			max = Math.max(max, curr);
			Long p = t.higher(curr);
			if (p != null) {
				max = Math.max(max, (curr - p + m) % m);
			}
			t.add(curr);
		}
		return max;
	}

	public static long minimumPasses(long m, long w, long p, long n) {
		long candies = 0;
		long invest = 0;
		long spend = Long.MAX_VALUE;

		while (candies < n) {
			long passes = (long) (((p - candies) / (double) m) / w);
			if (passes <= 0) {
				long mw = candies / p + m + w;
				long half = mw >>> 1;
				if (m > w) {
					m = Math.max(m, half);
					w = mw - m;
				} else {
					w = Math.max(w, half);
					m = mw - w;
				}
				candies %= p;
				passes++;
			}

			long mw;
			long pmw;
			try {
				mw = Math.multiplyExact(m, w);
				pmw = Math.multiplyExact(passes, mw);
			} catch (ArithmeticException ex) {
				invest += 1;
				spend = Math.min(spend, invest + 1);
				break;
			}
			candies += pmw;
			invest += passes;
			long increment = (long) Math.ceil((n - candies) / (double) mw);
			spend = Math.min(spend, invest + increment);
		}
		return Math.min(spend, invest);
	}

	static int maxSubsetSum(int[] arr) {
		if (arr.length == 0)
			return 0;
		arr[0] = Math.max(0, arr[0]);
		if (arr.length == 1)
			return arr[0];
		arr[1] = Math.max(arr[0], arr[1]);
		for (int i = 2; i < arr.length; i++)
			arr[i] = Math.max(arr[i - 1], arr[i] + arr[i - 2]);
		return arr[arr.length - 1];
	}

	public static String abbreviation(String a, String b) {
		boolean[][] dp = new boolean[b.length() + 1][a.length() + 1];
		dp[0][0] = true;

		for (int j = 1; j < dp[0].length; j++) {
			if (Character.isLowerCase(a.charAt(j - 1)))
				dp[0][j] = dp[0][j - 1];
		}

		for (int i = 1; i < dp.length; i++) {
			for (int j = 1; j < dp[0].length; j++) {
				char ca = a.charAt(j - 1), cb = b.charAt(i - 1);
				if (ca >= 'A' && ca <= 'Z') {
					if (ca == cb) {
						dp[i][j] = dp[i - 1][j - 1];
					}
				} else {
					ca = Character.toUpperCase(ca);
					if (ca == cb)
						dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1];
					else
						dp[i][j] = dp[i][j - 1];
				}
			}
		}

		return dp[b.length()][a.length()] ? "YES" : "NO";

	}

	public static long candies(int n, List<Integer> arr) {
		return candiesUtil(arr, 0, n - 1);
	}

	private static long candiesUtil(List<Integer> arr, int l, int r) {
		int count = 0;
		if (l < r) {
			int m = (l + r) / 2;
			if(arr.get(m) > arr.get(l)) {
				count +1
			}
		}
		return count;;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-17 14:28:02.580
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-17 14:28:02.587
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-17 14:28:02.647
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.hackerrank;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

public class HackerRankTest {

	public static void main(String[] args) {

		// Sock Merchant
		System.out.println("Sock Merchant");
		List<Integer> ar = Arrays.asList(1, 2, 1, 2, 1, 3, 2);
		System.out.println(HackerRankTest.sockMerchant(ar.size(), ar));

		// Valley Test
		System.out.println("Valley Test");
		String path = "UDDDUDUU";
		System.out.println(HackerRankTest.countingValleys(path.length(), path));

		// Jumping in the clouds
		System.out.println("Jumping in the clouds");
		List<Integer> cloud = Arrays.asList(0, 1, 0, 0, 0, 1, 0);
		System.out.println(HackerRankTest.jumpingOnClouds(cloud));

		// Repeated String
		System.out.println("Repeated String");
		System.out.println(HackerRankTest.repeatedString("abcac", 10));
		System.out.println(HackerRankTest.repeatedString("dcd", 10));
		System.out.println(HackerRankTest.repeatedString("a", 10));

		// Hourglass sum
		System.out.println("Hourglass sum");
		int[][] array = { { -9, -9, -9, 1, 1, 1 }, { 0, -9, 0, 4, 3, 2 }, { -9, -9, -9, 1, 2, 3 }, { 0, 0, 8, 6, 6, 0 },
				{ 0, 0, 0, -2, 0, 0 }, { 0, 0, 1, 2, 4, 0 } };
		List<List<Integer>> list = new ArrayList<List<Integer>>();
		for (int i = 0; i < array.length; i++) {
			List<Integer> data = new ArrayList<Integer>();
			for (int j = 0; j < array[0].length; j++) {
				data.add(array[i][j]);
			}
			list.add(data);
		}
		System.out.println(list);
		System.out.println(HackerRankTest.hourglassSum(list));

		// Left Rotate array
		System.out.println("Left Rotate Array");
		List<Integer> nums = Arrays.asList(1, 3, 2, 4, 5, 6, 7);
		System.out.println(nums);
		System.out.println(HackerRankTest.rotLeft(nums, 3));

		// Mininum Bribes
		System.out.println("Minimum Bribes");
		List<Integer> position = new ArrayList<Integer>();
		int[] pos = { 1, 2, 5, 3, 7, 8, 6, 4 };
		for (int i = 0; i < pos.length; i++) {
			position.add(pos[i]);
		}
		HackerRankTest.minimumBribes(position);

		// Minimum swaps
		System.out.println("Minimum Swaps");
		System.out.println(HackerRankTest.minimumSwaps(pos));

		// Array manipulation
		List<Integer> query1 = Arrays.asList(1, 2, 100);
		List<Integer> query2 = Arrays.asList(2, 5, 100);
		List<Integer> query3 = Arrays.asList(3, 4, 100);
		List<List<Integer>> queries = new ArrayList<List<Integer>>();
		queries.add(query1);
		queries.add(query2);
		queries.add(query3);
		System.out.println("Array manipulation");
		System.out.println(HackerRankTest.arrayManipulation(5, queries));

		// Hashtable : Ransom Note
		System.out.println("Hashtable : Ransom Note");
		List<String> magazine = Arrays.asList("give", "me", "one", "grand", "today", "night");
		List<String> note = Arrays.asList("give", "one", "grand", "today");
		HackerRankTest.checkMagazine(magazine, note);
		magazine = Arrays.asList("two", "times", "three", "is", "not", "four");
		note = Arrays.asList("two", "times", "two", "is", "four");
		HackerRankTest.checkMagazine(magazine, note);

		// Two Strings have common substring
		System.out.println("Two String have common substring");
		System.out.println(HackerRankTest.twoStrings("abc", "ab"));
		System.out.println(HackerRankTest.twoStrings("abc", "def"));

		// Anagram list of a string
		System.out.println("Anagram list of a string");
		System.out.println(HackerRankTest.sherlockAndAnagrams("abba"));

		// Count triplets of geometric progression
		System.out.println("Count triplets of geometric progression");
		List<Long> values = Arrays.asList(1L, 3L, 9L, 9L, 27L, 81L);
		System.out.println(HackerRankTest.countTriplets(values, 3));

		// Frequency query

		// Bubble sort
		System.out.println("Bubble Sort");
		List<Integer> unsorted = Arrays.asList(3, 2, 1);
		HackerRankTest.countSwaps(unsorted);

		// Activity notification
		System.out.println("Activity notification");
		List<Integer> txns = Arrays.asList(10, 20, 30, 40, 50);
		System.out.println(HackerRankTest.activityNotifications(txns, 3));

		// Array Sort Swap Count
		System.out.println("Array Sort Swap Count");
		List<Integer> counts = Arrays.asList(2, 1, 3, 1, 2);
		System.out.println(HackerRankTest.countInversions(counts));
		System.out.println(counts);

		// Remove characters to make anagram
		System.out.println("Remove characters to make anagram");
		System.out.println(HackerRankTest.makeAnagram("fcrxzwscanmligyxyvym", "jxwtrhvujlmrpdoqbisbwhmgpmeoke"));

		// Alternating characters
		System.out.println("Remove characters to make string alternating");
		System.out.println(HackerRankTest.alternatingCharacters("AAABBB"));

		// Sherlock and the valid string
		System.out.println("Sherlock and the valid string");
		System.out.println(HackerRankTest.isValid("aabbccddeefghi"));
		System.out.println(HackerRankTest.isValid("abcc"));
		System.out.println(HackerRankTest.isValid("abccc"));

		// Special Substring count
		System.out.println("Special Substring count");
		String s = "mnonopoo";
		System.out.println(HackerRankTest.substrCount(s.length(), s));
		s = "abcbaba";
		System.out.println(HackerRankTest.substrCount(s.length(), s));

		// Common Child Algorithm
		System.out.println("Common Child Algorithm");
		System.out.println(HackerRankTest.commonChild("ABCD", "ABDC"));
		System.out.println(HackerRankTest.commonChild("SHINCHAN", "NOHARAAA"));
		System.out.println(HackerRankTest.commonChild("ABCDEF", "FBDAMN"));
		System.out.println(HackerRankTest.commonChild("AA", "BB"));

		// Minimum absolute difference
		System.out.println("Minimum absolute difference");
		List<Integer> min = Arrays.asList(3, -7, 0);
		System.out.println(HackerRankTest.minimumAbsoluteDifference(min));
		min = Arrays.asList(-59, -36, -13, 1, -53, -92, -2, -96, -54, 75);
		System.out.println(HackerRankTest.minimumAbsoluteDifference(min));

		// Luck Balance
		System.out.println("Luck Balance");
		List<List<Integer>> contests = Arrays.asList(Arrays.asList(5, 1), Arrays.asList(1, 1), Arrays.asList(4, 0));
		System.out.println(HackerRankTest.luckBalance(2, contests));
		System.out.println(HackerRankTest.luckBalance(1, contests));

		// Minimum cost for greedy florist
		System.out.println("Minimum cost for greedy florist");
		int[] flowers = { 1, 3, 5, 7, 9 };
		System.out.println(HackerRankTest.getMinimumCost(3, flowers));
		int[] flowers2 = { 2, 5, 6 };
		System.out.println(HackerRankTest.getMinimumCost(3, flowers2));
		System.out.println(HackerRankTest.getMinimumCost(2, flowers2));

		// Mininum Max-Min difference of a subarray
		System.out.println("Mininum Max-Min difference of a subarray");
		List<Integer> minMax = Arrays.asList(1, 4, 7, 2);
		System.out.println(HackerRankTest.maxMin(2, minMax));
		minMax = Arrays.asList(10, 100, 300, 200, 1000, 20, 30);
		System.out.println(HackerRankTest.maxMin(3, minMax));
		minMax = Arrays.asList(1, 2, 3, 4, 10, 20, 30, 40, 100, 200);
		System.out.println(HackerRankTest.maxMin(4, minMax));
		minMax = Arrays.asList(1, 2, 1, 2, 1);
		System.out.println(HackerRankTest.maxMin(2, minMax));

		// Reverse Shuffle Merge
		System.out.println("String - Reverse Shuffle Merge");
		System.out.println(HackerRankTest.reverseShuffleMerge("aeiouuoiea"));
		System.out.println(HackerRankTest.reverseShuffleMerge("abcdefgabcdefg"));
		System.out.println(HackerRankTest.reverseShuffleMerge("eggegg"));

		// What 2 flavors for a given value
		System.out.println("What 2 flavors for a given value");
		List<Integer> flavors = Arrays.asList(2, 1, 3, 5, 6);
		HackerRankTest.whatFlavors(flavors, 5);

		// Minimum pass to create candies
		System.out.println("Minimum pass to create candies");
		System.out.println(HackerRankTest.minimumPasses(1L, 2L, 1L, 60L));

		// Max Subarray Sum
		System.out.println("Max Subarray Sum");
		int[] a = { -2, 1, 3, -4, 5 };
		System.out.println(HackerRankTest.maxSubsetSum(a));

		// Abbreviation of two strings
		System.out.println("Abbreviation of two strings");
		System.out.println(HackerRankTest.abbreviation("AbcDE", "ABDE"));
		System.out.println(HackerRankTest.abbreviation("daBcd", "ABC"));
		System.out.println(HackerRankTest.abbreviation("AbcDE", "AFDE"));
	}

	public static int sockMerchant(int n, List<Integer> ar) {
		HashMap<Integer, Integer> count = new HashMap<>();
		for (Integer color : ar) {
			if (count.containsKey(color)) {
				int newCount = count.get(color) + 1;
				count.put(color, newCount);
			} else {
				count.put(color, 1);
			}
		}
		int result = 0;
		for (Integer color : count.keySet()) {
			result += count.get(color) / 2;
		}
		return result;
	}

	public static int countingValleys(int steps, String path) {
		int v = 0;
		int lvl = 0;
		for (char c : path.toCharArray()) {
			if (c == 'U')
				++lvl;
			if (c == 'D')
				--lvl;

			if (lvl == 0 && c == 'U')
				++v;
		}
		return v;
	}

	public static int jumpingOnClouds(List<Integer> c) {
		int count = -1;
		for (int i = 0; i < c.size(); i++, count++) {
			if (i < c.size() - 2 && c.get(i + 2) == 0)
				i++;
		}
		return count;
	}

	public static long repeatedString(String s, long n) {
		char[] c = s.toLowerCase().toCharArray();
		int l = c.length;
		if (l == 1 && c[0] == 'a') {
			return n;
		}
		int count = 0;
		for (int i = 0; i < l; i++) {
			if (c[i] == 'a') {
				count++;
			}
		}
		if (count == 0) {
			return count;
		}
		if (n % l == 0) {
			return (n / l) * count;
		} else {
			long repetition = (n / l) * count;
			long remainder = n % l;
			int temp = 0;
			for (int i = 0; i < remainder; i++) {
				if (c[i] == 'a') {
					temp++;
				}
			}
			return repetition + temp;
		}
	}

	public static int hourglassSum(List<List<Integer>> arr) {
		int result = Integer.MIN_VALUE;
		int rows = arr.size();
		int columns = arr.get(0).size();
		int i = 0, j = 0;
		while (i < rows - 2) {
			j = 0;
			while (j < columns - 2) {
				int row1 = arr.get(i).get(j) + arr.get(i).get(j + 1) + arr.get(i).get(j + 2);
				int row2 = arr.get(i + 1).get(j + 1);
				int row3 = arr.get(i + 2).get(j) + arr.get(i + 2).get(j + 1) + arr.get(i + 2).get(j + 2);
				result = Math.max(result, (row1 + row2 + row3));
				j++;
			}
			i++;
		}
		return result;
	}

	public static List<Integer> rotLeft(List<Integer> a, int d) {
		int size = a.size();
		d = (d % size) * -1;
		if (a.size() == 0) {
			return a;
		} else if (d < 0) {
			d += size;
		}
		if (d == 0) {
			return a;
		}

		for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
			Integer displaced = a.get(cycleStart);
			int i = cycleStart;
			do {
				i += d;
				if (i >= size)
					i -= size;
				displaced = a.set(i, displaced);
				nMoved++;
			} while (i != cycleStart);
		}
		return a;
	}

	public static void minimumBribes(List<Integer> q) {
		int bribe = 0;
		boolean chaotic = false;
		int n = q.size();
		for (int i = 0; i < n; i++) {
			if (q.get(i) - (i + 1) > 2) {
				chaotic = true;
				break;
			}
			for (int j = Math.max(0, q.get(i) - 2); j < i; j++) {
				if (q.get(j) > q.get(i))
					bribe++;
			}
		}
		if (chaotic)
			System.out.println("Too chaotic");
		else
			System.out.println(bribe);
	}

	static int minimumSwaps(int[] arr) {
		int swap = 0;
		for (int i = 0; i < arr.length; i++) {
			if (i + 1 != arr[i]) {
				int t = i;
				while (arr[t] != i + 1) {
					t++;
				}
				int temp = arr[t];
				arr[t] = arr[i];
				arr[i] = temp;
				swap++;
			}
		}
		return swap;
	}

	public static long arrayManipulation(int n, List<List<Integer>> queries) {
		long[] start = new long[n + 1];
		long[] end = new long[n + 1];
		long max = -1L;
		long sum = 0L;
		for (int i = 0; i < queries.size(); i++) {
			int a = queries.get(i).get(0);
			int b = queries.get(i).get(1);
			long k = queries.get(i).get(2);
			start[a] += k;
			end[b] += k;
		}
		for (int i = 1; i < n + 1; i++) {
			sum += start[i];
			if (sum > max) {
				max = sum;
			}
			sum -= end[i];
		}
		return max;
	}

	public static void checkMagazine(List<String> magazine, List<String> note) {
		if (note == null || note.isEmpty() || magazine == null || magazine.isEmpty()
				|| (note.size() > magazine.size())) {
			System.out.println("No");
			return;
		}

		HashMap<String, Integer> count = new HashMap<String, Integer>();

		for (String key : magazine) {
			if (count.containsKey(key)) {
				count.put(key, count.get(key) + 1);
			} else {
				count.put(key, 1);
			}
		}

		for (String noteValue : note) {
			if (count.containsKey(noteValue)) {
				count.put(noteValue, count.get(noteValue) - 1);
				if (count.get(noteValue) < 0) {
					System.out.println("No");
					return;
				}
			} else {
				System.out.println("No");
				return;
			}
		}
		System.out.println("Yes");
	}

	public static String twoStrings(String s1, String s2) {
		Set<Character> one = new HashSet<Character>();
		Set<Character> two = new HashSet<Character>();
		for (Character c1 : s1.toCharArray()) {
			one.add(c1);
		}
		for (Character c2 : s2.toCharArray()) {
			two.add(c2);
		}

		one.retainAll(two);
		if (!one.isEmpty()) {
			return "YES";
		}
		return "NO";
	}

	public static int sherlockAndAnagrams(String s) {
		int result = 0;
		Map<String, Integer> count = new HashMap<String, Integer>();
		for (int i = 0; i < s.length(); i++) {
			for (int j = i; j < s.length(); j++) {
				char[] array = s.substring(i, j + 1).toCharArray();
				Arrays.sort(array);
				String sub = new String(array);
				System.out.println(sub);
				if (count.containsKey(sub)) {
					count.put(sub, count.get(sub) + 1);
				} else {
					count.put(sub, 1);
				}
			}
		}
		for (String key : count.keySet()) {
			int v = count.get(key);
			result += (v * (v - 1)) / 2;
		}
		return result;
	}

	static long countTriplets(List<Long> arr, long r) {
		Map<Long, Long> rightMap = getOccurenceMap(arr);
		Map<Long, Long> leftMap = new HashMap<>();
		long numberOfGeometricPairs = 0;

		for (long val : arr) {
			long countLeft = 0;
			long countRight = 0;
			long lhs = 0;
			long rhs = val * r;
			if (val % r == 0) {
				lhs = val / r;
			}
			Long occurence = rightMap.get(val);
			rightMap.put(val, occurence - 1L);

			if (rightMap.containsKey(rhs)) {
				countRight = rightMap.get(rhs);
			}
			if (leftMap.containsKey(lhs)) {
				countLeft = leftMap.get(lhs);
			}
			numberOfGeometricPairs += countLeft * countRight;
			insertIntoMap(leftMap, val);
		}
		return numberOfGeometricPairs;
	}

	private static Map<Long, Long> getOccurenceMap(List<Long> test) {
		Map<Long, Long> occurenceMap = new HashMap<>();
		for (long val : test) {
			insertIntoMap(occurenceMap, val);
		}
		return occurenceMap;
	}

	private static void insertIntoMap(Map<Long, Long> occurenceMap, Long val) {
		if (!occurenceMap.containsKey(val)) {
			occurenceMap.put(val, 1L);
		} else {
			Long occurence = occurenceMap.get(val);
			occurenceMap.put(val, occurence + 1L);
		}
	}

	static List<Integer> freqQuery(List<List<Integer>> queries) {
		List<Integer> ans = new ArrayList<>();
		Map<Integer, Integer> map = new HashMap<>();
		int maxFr = 0;
		for (List<Integer> ops : queries) {
			int op = ops.get(0);
			int data = ops.get(1);
			Integer v = map.get(data) == null ? 0 : map.get(data);
			if (op == 1) {
				map.put(data, ++v);
				maxFr = Math.max(maxFr, v);
			} else if (op == 2) {
				if (v > 0) {
					map.put(data, --v);
				}
			} else {
				if (data <= maxFr && map.containsValue(data))
					ans.add(1);
				else
					ans.add(0);
			}
		}
		return ans;
	}

	public static void countSwaps(List<Integer> a) {
		int n = a.size();
		int swapCount = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n - 1; j++) {
				if (a.get(j) > a.get(j + 1)) {
					swap(a, j, j + 1);
					swapCount++;
				}
			}
		}
		System.out.println("Array is sorted in " + swapCount + " swaps.");
		System.out.println("First Element: " + a.get(0));
		System.out.println("Last Element: " + a.get(n - 1));
	}

	private static void swap(List<Integer> a, int n, int m) {
		int temp = a.get(n);
		a.set(n, a.get(m));
		a.set(m, temp);
	}

	public static int maximumToys(List<Integer> prices, int k) {
		int pl = prices.size();
		int total = prices.stream().reduce(Integer::sum).get();
		if (k >= total)
			return pl;

		prices.sort(Comparator.reverseOrder());
		int reducedPrice = 0;
		for (int i = 0; i < pl; i++) {
			reducedPrice += prices.get(i);
			if (k >= total - reducedPrice) {
				return (pl - i - 1);
			}
		}

		return 0;
	}

	public static int activityNotificationsTemp(List<Integer> expenditure, int d) {
		int size = expenditure.size();
		int notifications = 0;
		if (size <= d) {
			return notifications;
		}

		for (int i = 0; i < size - d; i++) {
			int mean = expenditure.subList(i, d + i).stream().reduce(0, Integer::sum) / d;
			if ((mean * 2) > expenditure.get(d + i)) {
				notifications++;
			}
		}
		return notifications;
	}

	static int activityNotifications(List<Integer> expenditure, int d) {

		int notificationCount = 0;
		int[] data = new int[201];

		for (int i = 0; i < d; i++) {
			data[expenditure.get(i)]++;
		}

		for (int i = d; i < expenditure.size(); i++) {
			double median = getMedian(d, data);
			if (expenditure.get(i) >= 2 * median) {
				notificationCount++;

			}
			data[expenditure.get(i)]++;
			data[expenditure.get(i - d)]--;
		}
		return notificationCount;
	}

	private static double getMedian(int d, int[] data) {
		double median = 0;
		if (d % 2 == 0) {
			Integer m1 = null;
			Integer m2 = null;
			int count = 0;
			for (int j = 0; j < data.length; j++) {
				count += data[j];
				if (m1 == null && count >= d / 2) {
					m1 = j;
				}
				if (m2 == null && count >= d / 2 + 1) {
					m2 = j;
					break;
				}
			}
			median = (m1 + m2) / 2.0;
		} else {
			int count = 0;
			for (int j = 0; j < data.length; j++) {
				count += data[j];
				if (count > d / 2) {
					median = j;
					break;
				}
			}
		}
		return median;
	}

	public static long countInversions(List<Integer> arr) {
		long swapCount = 0;
		int[] helper = new int[arr.size()];
		return mergeSort(arr, 0, arr.size() - 1, helper, swapCount);
	}

	private static long mergeSort(List<Integer> arr, int l, int r, int[] helper, long swapCount) {
		if (l < r) {
			int m = (l + r) / 2;
			swapCount = mergeSort(arr, l, m, helper, swapCount) + mergeSort(arr, m + 1, r, helper, swapCount)
					+ merge(arr, l, m, r, helper, swapCount);
		}
		return swapCount;
	}

	private static long merge(List<Integer> arr, int l, int m, int r, int[] helper, long swapCount) {
		for (int i = l; i <= r; i++) {
			helper[i] = arr.get(i);
		}

		int curr = l;
		int left = l;
		int right = m + 1;

		while (left <= m && right <= r) {
			if (helper[left] <= helper[right]) {
				arr.set(curr++, helper[left++]);
			} else {
				swapCount += m + 1 - left;
				arr.set(curr++, helper[right++]);
			}
		}

		while (left <= m) {
			arr.set(curr++, helper[left++]);
		}
		return swapCount;
	}

	public static int makeAnagram(String a, String b) {
		int cArr[] = new int[26];
		for (int i = 0; i < a.length(); i++)
			cArr[a.charAt(i) - 97]++;
		for (int i = 0; i < b.length(); i++)
			cArr[b.charAt(i) - 97]--;
		int count = 0;
		for (int i = 0; i < 26; i++)
			count += Math.abs(cArr[i]);
		return count;
	}

	public static int alternatingCharacters(String s) {
		int count = 0;
		char lastItem = 0;

		for (char item : s.toCharArray()) {
			if (lastItem == item) {
				count++;
			}
			lastItem = item;
		}
		return count;
	}

	public static String isValid(String s) {
		final String YES = "YES";
		final String NO = "NO";
		if (s.isEmpty()) {
			return NO;
		} else if (s.length() <= 3) {
			return YES;
		}
		int cArr[] = new int[26];
		for (int i = 0; i < s.length(); i++)
			cArr[s.charAt(i) - 97]++;
		Arrays.sort(cArr);
		int i = 0;
		while (cArr[i] == 0) {
			i++;
		}
		int min = cArr[i];
		int max = cArr[25];

		if (min == max) {
			return YES;
		} else if ((max - min == 1) && (max > cArr[24]) || (min == 1) && (cArr[i + 1] == max)) {
			return YES;
		}
		return NO;
	}

	static long substrCount(int n, String s) {
		long res = n;
		for (int i = 0; i < n; i++) {
			boolean isAfterMedian = false;
			int beforeMedian = 1;
			char current = s.charAt(i);
			for (int j = i + 1; j < n; j++) {
				if (!isAfterMedian) {
					if (s.charAt(j) == current) {
						res++;
						beforeMedian++;
					}
					if (s.charAt(j) != current) {
						isAfterMedian = true;
					}
					;
				} else {
					if (s.charAt(j) == current && beforeMedian > 0) {
						beforeMedian--;
						if (beforeMedian == 0)
							res++;
					} else {
						break;
					}
				}
			}
		}
		return res;
	}

	public static int commonChild(String s1, String s2) {
		char[] s1_array = s1.toUpperCase().toCharArray();
		char[] s2_array = s2.toUpperCase().toCharArray();
		int[] count = new int[s1.length() + 1];

		for (int i = 1; i <= s1.length(); i++) {
			int prev = 0;
			for (int j = 1; j <= s2.length(); j++) {
				int temp = count[j];
				if (s1_array[i - 1] == s2_array[j - 1]) {
					count[j] = prev + 1;
				} else {
					count[j] = Math.max(count[j], count[j - 1]);
				}
				prev = temp;
			}
		}
		return count[s1.length()];
	}

	public static int minimumAbsoluteDifference(List<Integer> arr) {
		int[] intArr = arr.stream().sorted().mapToInt(Integer::intValue).toArray();
		int minAbsDiff = Integer.MAX_VALUE;
		for (int i = 0; i < intArr.length - 1; i++) {
			minAbsDiff = Math.min(minAbsDiff, Math.abs(intArr[i] - intArr[i + 1]));
		}
		return minAbsDiff;
	}

	public static int luckBalance(int k, List<List<Integer>> contests) {
		int size = contests.size();
		int loseCount = 0;
		int luckCount = 0;
		Collections.sort(contests, new Comparator<List<Integer>>() {
			@Override
			public int compare(List<Integer> o1, List<Integer> o2) {
				return o2.get(0).compareTo(o1.get(0));
			}
		});

		for (int i = 0; i < size; i++) {
			if (contests.get(i).get(1) == 1) {
				if (loseCount < k) {
					luckCount += contests.get(i).get(0);
					loseCount++;
				} else {
					luckCount -= contests.get(i).get(0);
				}
			} else {
				luckCount += contests.get(i).get(0);
			}
		}
		return luckCount;
	}

	static int getMinimumCost(int k, int[] c) {
		Arrays.sort(c);
		int i = c.length - 1;
		int bought = 0;
		int total = 0;
		// start backwards from the most expensive flower, stop when there is no more
		// flowers left
		while (i >= 0) {
			// Calculate total
			// increment bought by 1 when everyone in the group has bought equal number of
			// flowers
			for (int j = 0; j < k && i >= 0; j++) {
				total += (1 + bought) * c[i];
				i--;
			}
			bought++;
		}
		return total;
	}

	public static int maxMin(int k, List<Integer> arr) {
		int[] a = arr.stream().sorted().mapToInt(x -> x).toArray();
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < a.length - k + 1; i++) {
			min = Math.min(min, a[i + k - 1] - a[i]);
		}
		return min;
	}

	public static String reverseShuffleMerge(String s) {
		int[] count = new int[26], used = new int[26], rem = new int[26];
		StringBuilder sb = new StringBuilder();

		for (int i = 0; i < s.length(); i++) {
			count[s.charAt(i) - 'a']++;
		}
		for (int i = 0; i < count.length; i++) {
			rem[i] = count[i];
		}

		for (int i = s.length() - 1; i >= 0; i--) {
			char c = s.charAt(i);
			if (sb.length() == 0) {
				sb.append(c);
				used[c - 'a']++;
			} else {
				if (2 * used[c - 'a'] == count[c - 'a']) {
					rem[c - 'a']--;
					continue;
				}

				while (sb.length() > 0) {
					char last = sb.charAt(sb.length() - 1);
					if (c < last && 2 * (rem[last - 'a'] + used[last - 'a']) > count[last - 'a']) {
						used[last - 'a']--;
						sb.deleteCharAt(sb.length() - 1);
					} else {
						break;
					}
				}

				sb.append(c);
				used[c - 'a']++;
			}
			rem[c - 'a']--;
		}
		return sb.toString();
	}

	public static void whatFlavors(List<Integer> cost, int money) {
		Map<Integer, Integer> hash = new HashMap<Integer, Integer>();

		int[] res = new int[2];

		for (int i = 0; i < cost.size(); i++) {
			hash.put(cost.get(i), i);
		}

		for (int i = 0; i < cost.size(); i++) {
			int k = money - cost.get(i);
			if (hash.containsKey(k) && hash.get(k) != i) {
				res[0] = i + 1;
				res[1] = hash.get(k) + 1;
				break;
			}
		}

		System.out.printf("%d %d%n", res[0], res[1]);
	}

	public static int pairs(int k, List<Integer> arr) {
		int count;
		HashSet<Integer> set = new HashSet<>(arr);
		count = (int) arr.stream().filter(number -> set.contains(number + k)).count();
		return count;
	}

	static long triplets(int[] a, int[] b, int[] c) {

		long count = 0;

		a = Arrays.stream(a).sorted().distinct().toArray();
		b = Arrays.stream(b).sorted().distinct().toArray();
		c = Arrays.stream(c).sorted().distinct().toArray();

		for (int i = 0; i < b.length; i++) {
			int c1 = getIndex(a, b[i]) + 1;
			int c2 = getIndex(c, b[i]) + 1;
			if (c1 == -1 || c2 == -1)
				continue;
			count += (long) c1 * (long) c2;
		}
		return count;
	}

	public static int getIndex(int[] arr, int e) {
		int index = -1;
		int l = 0, r = arr.length - 1;
		while (l <= r) {
			int mid = (l + r) / 2;
			if (arr[mid] <= e) {
				if (arr[mid] == e) {
					index = mid;
					break;
				}
				index = mid;
				l = mid + 1;
			} else
				r = mid - 1;
		}
		return index;
	}

	static long minTime(long[] machines, long goal) {
		Arrays.sort(machines);
		long max = (machines[machines.length - 1]) * goal;
		long min = 0;
		long result = -1;
		while (max > min) {
			long midValue = (max + min) / 2;
			long unit = 0;
			for (long machine : machines) {
				unit += midValue / machine;
			}
			if (unit < goal) {
				min = midValue + 1;
				result = midValue + 1;
			} else {
				max = midValue;
				result = midValue;
			}
		}
		return result;
	}

	public static long maximumSum(List<Long> a, long m) {
		long max = 0, curr = 0;
		TreeSet<Long> t = new TreeSet<>();
		for (int i = 0; i < a.size(); i++) {
			curr = (curr + a.get(i) % m) % m;
			max = Math.max(max, curr);
			Long p = t.higher(curr);
			if (p != null) {
				max = Math.max(max, (curr - p + m) % m);
			}
			t.add(curr);
		}
		return max;
	}

	public static long minimumPasses(long m, long w, long p, long n) {
		long candies = 0;
		long invest = 0;
		long spend = Long.MAX_VALUE;

		while (candies < n) {
			long passes = (long) (((p - candies) / (double) m) / w);
			if (passes <= 0) {
				long mw = candies / p + m + w;
				long half = mw >>> 1;
				if (m > w) {
					m = Math.max(m, half);
					w = mw - m;
				} else {
					w = Math.max(w, half);
					m = mw - w;
				}
				candies %= p;
				passes++;
			}

			long mw;
			long pmw;
			try {
				mw = Math.multiplyExact(m, w);
				pmw = Math.multiplyExact(passes, mw);
			} catch (ArithmeticException ex) {
				invest += 1;
				spend = Math.min(spend, invest + 1);
				break;
			}
			candies += pmw;
			invest += passes;
			long increment = (long) Math.ceil((n - candies) / (double) mw);
			spend = Math.min(spend, invest + increment);
		}
		return Math.min(spend, invest);
	}

	static int maxSubsetSum(int[] arr) {
		if (arr.length == 0)
			return 0;
		arr[0] = Math.max(0, arr[0]);
		if (arr.length == 1)
			return arr[0];
		arr[1] = Math.max(arr[0], arr[1]);
		for (int i = 2; i < arr.length; i++)
			arr[i] = Math.max(arr[i - 1], arr[i] + arr[i - 2]);
		return arr[arr.length - 1];
	}

	public static String abbreviation(String a, String b) {
		boolean[][] dp = new boolean[b.length() + 1][a.length() + 1];
		dp[0][0] = true;

		for (int j = 1; j < dp[0].length; j++) {
			if (Character.isLowerCase(a.charAt(j - 1)))
				dp[0][j] = dp[0][j - 1];
		}

		for (int i = 1; i < dp.length; i++) {
			for (int j = 1; j < dp[0].length; j++) {
				char ca = a.charAt(j - 1), cb = b.charAt(i - 1);
				if (ca >= 'A' && ca <= 'Z') {
					if (ca == cb) {
						dp[i][j] = dp[i - 1][j - 1];
					}
				} else {
					ca = Character.toUpperCase(ca);
					if (ca == cb)
						dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1];
					else
						dp[i][j] = dp[i][j - 1];
				}
			}
		}

		return dp[b.length()][a.length()] ? "YES" : "NO";

	}

	public static long candies(int n, List<Integer> arr) {
		return candiesUtil(arr, 0, n - 1);
	}

	private static long candiesUtil(List<Integer> arr, int l, int r) {
		int count = 0;
		if (l < r) {
			int m = (l + r) / 2;
			if(arr.get(m) > arr.get(l)) {
				count +1
			}
		}
		return count;;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-17 14:28:02.652
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-17 14:28:02.656
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-17 22:28:52.475
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Coding Practice/bin/com/test/leetcode/ListNode.class)[275]: java.lang.Exception: A resource exists with a different case: '/Coding Practice/bin/com/test/leetcode/ListNode.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:107)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:900)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:203)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:386)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:318)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:297)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:212)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2022-01-17 22:28:52.494
!MESSAGE A resource exists with a different case: '/Coding Practice/bin/com/test/leetcode/ListNode.class'.
!STACK 0
java.lang.Exception: A resource exists with a different case: '/Coding Practice/bin/com/test/leetcode/ListNode.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:107)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:900)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:203)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:386)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:318)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:297)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:212)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-17 22:29:18.021
!MESSAGE JavaBuilder handling CoreException
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Coding Practice/bin/com/test/leetcode/ListNode.class)[275]: java.lang.Exception: A resource exists with a different case: '/Coding Practice/bin/com/test/leetcode/ListNode.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:107)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:900)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:203)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:386)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:318)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:297)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:212)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.core.resources 4 275 2022-01-17 22:29:18.021
!MESSAGE A resource exists with a different case: '/Coding Practice/bin/com/test/leetcode/ListNode.class'.
!STACK 0
java.lang.Exception: A resource exists with a different case: '/Coding Practice/bin/com/test/leetcode/ListNode.class'.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:318)
	at org.eclipse.core.internal.resources.Resource.checkDoesNotExist(Resource.java:296)
	at org.eclipse.core.internal.resources.File.create(File.java:107)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFileContents(AbstractImageBuilder.java:900)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.writeClassFile(AbstractImageBuilder.java:879)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.acceptResult(AbstractImageBuilder.java:203)
	at org.eclipse.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:615)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:475)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:426)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:386)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:214)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:318)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:79)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:297)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:212)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-01-20 15:38:50.492 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.600
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-20 15:38:57.601
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-01-20 15:38:59.873
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-20 15:38:59.873
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58a0f75b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b569858,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-20 15:39:21.598
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:17.347
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:17.354
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:17.357
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:17.766
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-22 17:09:17.769
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-22 17:09:17.772
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:18.650
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:18.655
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:18.660
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:20.177
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:20.180
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:20.182
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:20.889
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:20.892
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:20.894
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:21.065
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:21.070
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:21.074
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:22.038
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:22.043
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:22.047
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:23.813
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-22 17:09:23.819
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-22 17:09:23.823
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:23.875
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:23.881
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:23.887
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:24.893
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:24.900
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:24.904
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:25.913
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:25.917
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:25.921
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-22 17:09:26.133
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.test.leetcode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class LeetCodeTest {

	// Letter Combinations of a Phone Number
	public List<String> letterCombinations(String digits) {
		List<String> ans = new LinkedList<String>();
		if (digits.isEmpty())
			return ans;
		String[] mapping = new String[] { "0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
		ans.add(0, "");
		for (int i = 0; i < digits.length(); i++) {
			int x = Character.getNumericValue(digits.charAt(i));
			int size = ans.size();
			for (int k = 1; k <= size; k++) {
				String t = ans.remove(0);
				for (char s : mapping[x].toCharArray())
					ans.add(t + s);
			}
		}
		return ans;
	}

	// Index of Sum of two values in an array equal to target
	public int[] twoSum(int[] nums, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(target - nums[i])) {
				result[1] = i;
				result[0] = map.get(target - nums[i]);
				return result;
			}
			map.put(nums[i], i);
		}
		return result;
	}

	// Add two numbers stored in reverse order in Linked List
	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
		int carry = 0;
		ListNode p, dummy = new ListNode(0);
		p = dummy;
		while (l1 != null || l2 != null || carry != 0) {
			if (l1 != null) {
				carry += l1.val;
				l1 = l1.next;
			}
			if (l2 != null) {
				carry += l2.val;
				l2 = l2.next;
			}
			p.next = new ListNode(carry % 10);
			carry /= 10;
			p = p.next;
		}
		return dummy.next;
	}

	// Longest Substring Without Repeating Characters
	public int lengthOfLongestSubstring(String s) {
		if (s.length() == 0)
			return 0;
		HashMap<Character, Integer> map = new HashMap<Character, Integer>();
		int max = 0;
		for (int i = 0, j = 0; i < s.length(); ++i) {
			if (map.containsKey(s.charAt(i))) {
				j = Math.max(j, map.get(s.charAt(i)) + 1);
			}
			map.put(s.charAt(i), i);
			max = Math.max(max, i - j + 1);
		}
		return max;
	}

	// Find median of two sorted arrays
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		if (nums1.length > nums2.length)
			return findMedianSortedArrays(nums2, nums1);
		int x = nums1.length;
		int y = nums2.length;
		int low = 0;
		int high = x;
		while (low <= high) {
			int partX = (low + high) / 2;
			int partY = (x + y + 1) / 2 - partX;
			int xLeft = partX == 0 ? Integer.MIN_VALUE : nums1[partX - 1];
			int xRight = partX == x ? Integer.MAX_VALUE : nums1[partX];
			int yLeft = partY == 0 ? Integer.MIN_VALUE : nums2[partY - 1];
			int yRight = partY == y ? Integer.MAX_VALUE : nums2[partY];
			if (xLeft <= yRight && yLeft <= xRight) {
				if ((x + y) % 2 == 0) {
					return ((double) Math.max(xLeft, yLeft) + Math.min(xRight, yRight)) / 2;
				} else {
					return Math.max(xLeft, yLeft);
				}
			} else if (xLeft > yRight) {
				high = partX - 1;
			} else {
				low = partX + 1;
			}
		}
		return 0;
	}

	// Longest Palindromic Substring
	public String longestPalindrome(String s) {
		int start = 0;
		int end = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			int left = i;
			int right = i;

			while (left >= 0 && s.charAt(left) == c) {
				left--;
			}

			while (right < s.length() && s.charAt(right) == c) {
				right++;
			}

			while (left >= 0 && right < s.length()) {
				if (s.charAt(left) != s.charAt(right)) {
					break;
				}
				left--;
				right++;
			}

			left = left + 1;
			if (end - start < right - left) {
				start = left;
				end = right;
			}
		}

		return s.substring(start, end);
	}

	// Zigzag conversion of a string
	public String convert(String s, int numRows) {
		char[] c = s.toCharArray();
		int len = c.length;
		StringBuffer[] sb = new StringBuffer[numRows];
		for (int i = 0; i < sb.length; i++)
			sb[i] = new StringBuffer();

		int i = 0;
		while (i < len) {
			for (int idx = 0; idx < numRows && i < len; idx++)
				sb[idx].append(c[i++]);
			for (int idx = numRows - 2; idx >= 1 && i < len; idx--)
				sb[idx].append(c[i++]);
		}
		for (int idx = 1; idx < sb.length; idx++)
			sb[0].append(sb[idx]);
		return sb[0].toString();
	}

	// String to integere ATOI
	public int myAtoi(String str) {
		int index = 0, sign = 1, total = 0;
		if (str.length() == 0 || (str.trim().length() == 0)) {
			return index;
		}
		while (index < str.length() && str.charAt(index) == ' ')
			index++;
		if (str.charAt(index) == '+' || str.charAt(index) == '-') {
			sign = str.charAt(index) == '+' ? 1 : -1;
			index++;
		}
		while (index < str.length()) {
			int digit = str.charAt(index) - '0';
			if (digit < 0 || digit > 9)
				break;
			if (Integer.MAX_VALUE / 10 < total || Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)
				return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
			total = 10 * total + digit;
			index++;
		}
		return total * sign;
	}

	public List<List<Integer>> threeSum(int[] nums) {
		List<List<Integer>> res = new ArrayList<>();
		Arrays.sort(nums);
		for (int i = 0; i + 2 < nums.length; i++) {
			if (i > 0 && nums[i] == nums[i - 1]) { // skip same result
				continue;
			}
			int j = i + 1, k = nums.length - 1;
			int target = -nums[i];
			while (j < k) {
				if (nums[j] + nums[k] == target) {
					res.add(Arrays.asList(nums[i], nums[j], nums[k]));
					j++;
					k--;
					while (j < k && nums[j] == nums[j - 1])
						j++; // skip same result
					while (j < k && nums[k] == nums[k + 1])
						k--; // skip same result
				} else if (nums[j] + nums[k] > target) {
					k--;
				} else {
					j++;
				}
			}
		}
		return res;
	}

	// Valid Parentheses for equation
	public boolean isValid(String s) {
		HashMap<Character, Character> brackets = new HashMap<>();
		brackets.put('(', ')');
		brackets.put('[', ']');
		brackets.put('{', '}');
		Deque<Character> stack = new LinkedList<>();

		for (Character c : s.toCharArray()) {
			if (brackets.containsKey(c))
				stack.push(c);
			else if (!c.equals(brackets.get(stack.poll())))
				return false;
		}
		return stack.isEmpty() ? true : false;
	}

	// Generate output string combinations based on input
	public List<String> generateParenthesis(int n) {
		List<String> list = new ArrayList<String>();
		generateOneByOne("", list, n, n);
		return list;
	}

	public void generateOneByOne(String sublist, List<String> list, int left, int right) {
		if (left > right) {
			return;
		}
		if (left > 0) {
			generateOneByOne(sublist + "(", list, left - 1, right);
		}
		if (right > 0) {
			generateOneByOne(sublist + ")", list, left, right - 1);
		}
		if (left == 0 && right == 0) {
			list.add(sublist);
			return;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		ListNode head = null, last = null;
		PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
			public int compare(ListNode a, ListNode b) {
				return a.val - b.val;
			}
		});

		for (int i = 0; i < lists.length; i++)
			if (lists[i] != null)
				pq.add(lists[i]);
		while (!pq.isEmpty()) {
			ListNode top = pq.peek();
			pq.remove();
			if (top.next != null)
				pq.add(top.next);
			if (head == null) {
				head = top;
				last = top;
			} else {
				last.next = top;
				last = top;
			}
		}
		return head;
	}

	// Trap Rain Water
	public int trap(int[] height) {
		int n = height.length;
		int result = 0;
		int left_max = 0, right_max = 0;
		int lo = 0, hi = n - 1;

		while (lo <= hi) {
			if (height[lo] < height[hi]) {
				if (height[lo] > left_max)
					left_max = height[lo];
				else
					result += left_max - height[lo];
				lo++;
			} else {
				if (height[hi] > right_max)
					right_max = height[hi];
				else
					result += right_max - height[hi];
				hi--;
			}
		}
		return result;
	}

	// All possible permutations for int array
	public List<List<Integer>> permute(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		ArrayList<Integer> perm = new ArrayList<Integer>();
		backTrack(perm, 0, nums, list);
		return list;
	}

	void backTrack(ArrayList<Integer> perm, int i, int[] nums, List<List<Integer>> list) {
		if (i == nums.length) {
			list.add(new ArrayList<Integer>(perm));
			return;
		}
		ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);
		for (int j = 0; j <= i; j++) {
			newPerm.add(j, nums[i]);
			backTrack(newPerm, i + 1, nums, list);
			newPerm.remove(j);
		}
	}

	// Matrix rotation in place - anticlockwise
	public void rotateAnticlockwise(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[i].length; j++) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[i][j];
				matrix[i][j] = temp;
			}
		}

		for (int i = 0; i < matrix[0].length; i++) {
			for (int j = 0, k = matrix[i].length - 1; j < k; j++, k--) {
				int temp = matrix[j][i];
				matrix[j][i] = matrix[k][i];
				matrix[k][i] = temp;
			}
		}
	}

	// Rotate matrix in place - clockwise
	public void rotate(int[][] matrix) {
		for (int i = 0; i < matrix.length; i++) {
			for (int j = i; j < matrix[0].length; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[j][i];
				matrix[j][i] = temp;
			}
		}
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix.length / 2; j++) {
				int temp = 0;
				temp = matrix[i][j];
				matrix[i][j] = matrix[i][matrix.length - 1 - j];
				matrix[i][matrix.length - 1 - j] = temp;
			}
		}
	}

	// Group anagrams of strings together
	public List<List<String>> groupAnagrams(String[] strs) {
		if (strs == null || strs.length == 0)
			return new ArrayList<>();
		Map<String, List<String>> map = new HashMap<>();
		for (String s : strs) {
			char[] ca = new char[26];
			for (char c : s.toCharArray())
				ca[c - 'a']++;
			String keyStr = String.valueOf(ca);
			if (!map.containsKey(keyStr))
				map.put(keyStr, new ArrayList<>());
			map.get(keyStr).add(s);
		}
		return new ArrayList<>(map.values());
	}

	// Merge overlapping intervals
	public int[][] merge(int[][] intervals) {
		if (intervals == null || intervals.length == 0)
			return intervals;
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
		LinkedList<int[]> mergedIntervals = new LinkedList<>();
		for (int[] curr : intervals) {
			if (mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])
				mergedIntervals.add(curr);
			else
				mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);
		}
		return mergedIntervals.toArray(new int[0][]);
	}

	public int[][] generateMatrix(int n) {
		int[][] result = new int[n][n];
		int r = n, c = n;
		int value = 0;
		int startRow = 0, startColumn = 0;
		while (startRow < r && startColumn < c) {
			for (int i = startColumn; i < c; i++) {
				value++;
				result[startRow][i] = value;
			}
			startRow++;
			for (int i = startRow; i < r; i++) {
				value++;
				result[i][c - 1] = value;
			}
			c--;
			if (startRow < r) {
				for (int i = c - 1; i >= startColumn; i--) {
					value++;
					result[r - 1][i] = value;
				}
				r--;
			}

			if (startColumn < c) {
				for (int i = r - 1; i >= startRow; i--) {
					value++;
					result[i][startColumn] = value;
				}
				startColumn++;
			}
		}
		return result;
	}

	// Robot problem - Unique paths to reach the bottom of a matrix
	public int uniquePathsWithObstacles(int[][] obstacleGrid) {
		int m = obstacleGrid.length;
		int n = obstacleGrid[0].length;

		obstacleGrid[0][0] ^= 1;
		for (int i = 1; i < m; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 1) ? 0 : obstacleGrid[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			obstacleGrid[0][j] = (obstacleGrid[0][j] == 1) ? 0 : obstacleGrid[0][j - 1];
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				obstacleGrid[i][j] = (obstacleGrid[i][j] == 1) ? 0 : obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
			}
		}
		return obstacleGrid[m - 1][n - 1];
	}

	// Minimum path sum in a matrix from top left to bottom right.
	public int minPathSum(int[][] grid) {
		int m = grid.length, n = grid[0].length;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (i == 0 && j != 0)
					grid[i][j] += grid[i][j - 1];
				if (i != 0 && j == 0)
					grid[i][j] += grid[i - 1][j];
				if (i != 0 && j != 0)
					grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
			}
		}
		return grid[m - 1][n - 1];
	}

	/*
	 * Given two strings word1 and word2, return the minimum number of operations
	 * required to convert word1 to word2.
	 * 
	 * You have the following three operations permitted on a word:
	 * 
	 * Insert a character Delete a character Replace a character
	 */
	public int minDistance(String word1, String word2) {
		if (word1.equals(word2)) {
			return 0;
		}
		if (word1.length() == 0 || word2.length() == 0) {
			return Math.abs(word1.length() - word2.length());
		}
		int[][] dp = new int[word1.length() + 1][word2.length() + 1];
		for (int i = 0; i <= word1.length(); i++) {
			dp[i][0] = i;
		}
		for (int i = 0; i <= word2.length(); i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= word1.length(); i++) {
			for (int j = 1; j <= word2.length(); j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
				}
			}
		}
		return dp[word1.length()][word2.length()];
	}

	// Set entire row and column as zero if zero present
	public void setZeroes(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return;
		}
		int m = matrix.length;
		int n = matrix[0].length;
		boolean first_row = false;
		boolean first_col = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				first_col = true;
				break;
			}
		}
		for (int j = 0; j < n; j++) {
			if (matrix[0][j] == 0) {
				first_row = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[i][0] = 0;
					matrix[0][j] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (first_row) {
			for (int j = 0; j < n; j++) {
				matrix[0][j] = 0;
			}
		}
		if (first_col) {
			for (int i = 0; i < m; i++) {
				matrix[i][0] = 0;
			}
		}
	}

	// Sort and group colors together in O(1) space using 1-pass
	public void sortColors(int[] nums) {
		if (nums == null || nums.length <= 1) {
			return;
		}

		int zeros = 0;
		int twos = nums.length - 1;
		int i = 0;

		while (i <= twos) {
			if (nums[i] == 0) {
				swap(nums, i, zeros);
				zeros++;
				i++;
			} else if (nums[i] == 2) {
				swap(nums, i, twos);
				twos--;
			} else {
				i++;
			}
		}
	}

	private void swap(int[] nums, int i, int j) {
		if (i != j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		}
	}

	/*
	 * Minimum Window Substring Given two strings s and t of lengths m and n
	 * respectively, return the minimum window substring of s such that every
	 * character in t (including duplicates) is included in the window. If there is
	 * no such substring, return the empty string "".
	 * 
	 * The testcases will be generated such that the answer is unique.
	 * 
	 * A substring is a contiguous sequence of characters within the string.
	 */

	public String minWindow(String s, String t) {
		if (s == null || t == null || s.length() < t.length() || t.length() == 0) {
			return "";
		}

		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < t.length(); i++) {
			map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
		}

		int start = 0;
		int end = 0;
		int charTLeft = t.length();
		int minStart = 0;
		int minLen = Integer.MAX_VALUE;

		while (end < s.length()) {
			char eChar = s.charAt(end);
			if (map.containsKey(eChar)) {
				int count = map.get(eChar);
				if (count > 0) {
					charTLeft--;
				}
				map.put(eChar, count - 1);
			}
			end++;

			while (charTLeft == 0) {
				if (minLen > end - start) {
					minLen = end - start;
					minStart = start;
				}
				char sChar = s.charAt(start);
				if (map.containsKey(sChar)) {
					int count = map.get(sChar);
					if (count == 0) {
						charTLeft++;
					}
					map.put(sChar, count + 1);
				}
				start++;
			}
		}

		return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
	}

	// Subsets
	/*
	 * Given an integer array nums of unique elements, return all possible subsets
	 * (the power set).
	 * 
	 * The solution set must not contain duplicate subsets. Return the solution in
	 * any order.
	 */
	public List<List<Integer>> subsets(int[] nums) {
		List<List<Integer>> list = new ArrayList<>();
		Arrays.sort(nums);
		backtrack(list, new ArrayList<>(), nums, 0);
		return list;
	}

	private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {
		list.add(new ArrayList<>(tempList));
		for (int i = start; i < nums.length; i++) {
			tempList.add(nums[i]);
			backtrack(list, tempList, nums, i + 1);
			tempList.remove(tempList.size() - 1);
		}
	}

	// Gray code
	/*
	 * An n-bit gray code sequence is a sequence of 2n integers where:
	 * 
	 * Every integer is in the inclusive range [0, 2n - 1], The first integer is 0,
	 * An integer appears no more than once in the sequence, The binary
	 * representation of every pair of adjacent integers differs by exactly one bit,
	 * and The binary representation of the first and last integers differs by
	 * exactly one bit.
	 */
	public List<Integer> grayCode(int n) {
		List<Integer> result = new LinkedList<>();
		for (int i = 0; i < 1 << n; i++)
			result.add(i ^ i >> 1);
		return result;
	}

	// Validate if left is lower than node, right is highe than node
	public boolean isValidBST(TreeNode root) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode cur = root;
		TreeNode pre = null;
		while (!stack.isEmpty() || cur != null) {
			if (cur != null) {
				stack.push(cur);
				cur = cur.left;
			} else {
				TreeNode p = stack.pop();
				if (pre != null && p.val <= pre.val) {
					return false;
				}
				pre = p;
				cur = p.right;
			}
		}
		return true;
	}

	// Validate if two Binary trees are equal
	public boolean isSameTree(TreeNode p, TreeNode q) {
		if ((p == null && q == null)) {
			return true;
		} else if (p != null && q != null) {
			return ((p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
		}
		return false;
	}

	// Level Order traversal of a BT
	public List<List<Integer>> levelOrder(TreeNode root) {
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		List<List<Integer>> wrapList = new LinkedList<List<Integer>>();

		if (root == null)
			return wrapList;

		queue.offer(root);
		while (!queue.isEmpty()) {
			int levelNum = queue.size();
			List<Integer> subList = new LinkedList<Integer>();
			for (int i = 0; i < levelNum; i++) {
				if (queue.peek().left != null)
					queue.offer(queue.peek().left);
				if (queue.peek().right != null)
					queue.offer(queue.peek().right);
				subList.add(queue.poll().val);
			}
			wrapList.add(subList);
		}
		return wrapList;
	}

	// Path sum from root to leaf equal to a given no - using BFS
	public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
		List<List<Integer>> ans = new ArrayList<>();
		List<Integer> path = new ArrayList<>();
		pathSum(ans, path, root, targetSum);
		return ans;
	}

	private void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int sum) {
		if (root == null)
			return;
		List<Integer> newPath = new ArrayList<>(path);
		newPath.add(root.val);
		if (root.left == null && root.right == null && root.val == sum) {
			ans.add(newPath);
			return;
		}
		pathSum(ans, newPath, root.left, sum - root.val);
		pathSum(ans, newPath, root.right, sum - root.val);
	}

	// Pascal's Triangle II
	/*
	 * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the
	 * Pascal's triangle.
	 * 
	 * In Pascal's triangle, each number is the sum of the two numbers directly
	 * above it as shown:
	 */
	public List<Integer> getRow(int rowIndex) {
		List<Integer> ret = new LinkedList<Integer>();
		if (rowIndex < 0) {
			return ret;
		}
		for (int row = 0; row <= rowIndex; row++) {
			ret.add(0, 1);
			for (int i = 1; i < row; i++)
				ret.set(i, ret.get(i) + ret.get(i + 1));
		}
		return ret;
	}

	// Best Time to Buy and Sell Stock
	/*
	 * You are given an array prices where prices[i] is the price of a given stock
	 * on the ith day.
	 * 
	 * You want to maximize your profit by choosing a single day to buy one stock
	 * and choosing a different day in the future to sell that stock.
	 * 
	 * Return the maximum profit you can achieve from this transaction. If you
	 * cannot achieve any profit, return 0.
	 */
	// Kadane's Algo
	public int maxProfit(int[] prices) {
		int maxCur = 0, maxSoFar = 0;
		for (int i = 1; i < prices.length; i++) {
			maxCur = Math.max(0, maxCur += prices[i] - prices[i - 1]);
			maxSoFar = Math.max(maxCur, maxSoFar);
		}
		return maxSoFar;
	}

	// Sum Root to Leaf Numbers
	/*
	 * You are given the root of a binary tree containing digits from 0 to 9 only.
	 * 
	 * Each root-to-leaf path in the tree represents a number.
	 * 
	 * For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
	 * Return the total sum of all root-to-leaf numbers. Test cases are generated so
	 * that the answer will fit in a 32-bit integer.
	 * 
	 * A leaf node is a node with no children.
	 */
	public int sumNumbers(TreeNode root) {
		return sum(root, 0);
	}

	public int sum(TreeNode n, int s) {
		if (n == null)
			return 0;
		if (n.right == null && n.left == null)
			return s * 10 + n.val;
		return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);
	}

	// Copy List with Random Pointer
	/*
	 * A linked list of length n is given such that each node contains an additional
	 * random pointer, which could point to any node in the list, or null.
	 * 
	 * Construct a deep copy of the list. The deep copy should consist of exactly n
	 * brand new nodes, where each new node has its value set to the value of its
	 * corresponding original node. Both the next and random pointer of the new
	 * nodes should point to new nodes in the copied list such that the pointers in
	 * the original list and copied list represent the same list state. None of the
	 * pointers in the new list should point to nodes in the original list.
	 */
	public Node copyRandomList(Node head) {
		HashMap<Node, Node> map = new HashMap<Node, Node>();
		Node p = head;
		while (p != null) {
			map.put(p, new Node(p.val));
			p = p.next;
		}
		Node q = head;
		while (q != null) {
			map.get(q).next = map.get(q.next);
			map.get(q).random = map.get(q.random);
			q = q.next;
		}
		return map.get(head);
	}

	// Word Break
	/*
	 * Given a string s and a dictionary of strings wordDict, return true if s can
	 * be segmented into a space-separated sequence of one or more dictionary words.
	 * 
	 * Note that the same word in the dictionary may be reused multiple times in the
	 * segmentation.
	 */
	public boolean wordBreak(String s, List<String> wordDict) {
		TrieNode t = new TrieNode(), cur;
		for (String i : wordDict)
			addWord(t, i);
		char[] str = s.toCharArray();
		int len = str.length;
		boolean[] f = new boolean[len + 1];
		f[len] = true;

		for (int i = len - 1; i >= 0; i--) {
			// System.out.println(str[i]);
			cur = t;
			for (int j = i; cur != null && j < len; j++) {
				cur = cur.c[(int) str[j]];
				if (cur != null && cur.isWord && f[j + 1]) {
					f[i] = true;
					break;
				}
			}
		}
		return f[0];
	}

	public void addWord(TrieNode t, String w) {
		for (int i = 0; i < w.length(); i++) {
			int j = (int) w.charAt(i);
			if (t.c[j] == null)
				t.c[j] = new TrieNode();
			t = t.c[j];
		}
		t.isWord = true;
	}

	// Linked List Cycle
	/*
	 * Given head, the head of a linked list, determine if the linked list has a
	 * cycle in it.
	 * 
	 * There is a cycle in a linked list if there is some node in the list that can
	 * be reached again by continuously following the next pointer. Internally, pos
	 * is used to denote the index of the node that tail's next pointer is connected
	 * to. Note that pos is not passed as a parameter.
	 * 
	 * Return true if there is a cycle in the linked list. Otherwise, return false.
	 */
	public boolean hasCycle(ListNode head) {
		ListNode slow_p = head, fast_p = head;
		int flag = 0;
		while (slow_p != null && fast_p != null && fast_p.next != null) {
			slow_p = slow_p.next;
			fast_p = fast_p.next.next;
			if (slow_p == fast_p) {
				flag = 1;
				break;
			}
		}
		return flag == 1 ? true : false;
	}

	// Sort a Linked List
	/*
	 * Given the head of a linked list, return the list after sorting it in
	 * ascending order.
	 */
	public ListNode sortList(ListNode head) {
		if (head == null || head.next == null)
			return head;
		ListNode mid = findMid(head);
		ListNode head2 = mid.next;
		mid.next = null;
		ListNode newHead1 = sortList(head);
		ListNode newHead2 = sortList(head2);
		ListNode finalHead = merge(newHead1, newHead2);
		return finalHead;
	}

	static ListNode merge(ListNode head1, ListNode head2) {
		ListNode merged = new ListNode(-1);
		ListNode temp = merged;
		while (head1 != null && head2 != null) {
			if (head1.val < head2.val) {
				temp.next = head1;
				head1 = head1.next;
			} else {
				temp.next = head2;
				head2 = head2.next;
			}
			temp = temp.next;
		}
		while (head1 != null) {
			temp.next = head1;
			head1 = head1.next;
			temp = temp.next;
		}
		while (head2 != null) {
			temp.next = head2;
			head2 = head2.next;
			temp = temp.next;
		}
		return merged.next;
	}

	private static ListNode findMid(ListNode head) {
		ListNode slow = head, fast = head.next;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	// Intersection of two linked lists
	public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode ptr1 = headA;
		ListNode ptr2 = headB;
		if (ptr1 == null || ptr2 == null) {
			return null;
		}
		while (ptr1 != ptr2) {
			ptr1 = ptr1.next;
			ptr2 = ptr2.next;
			if (ptr1 == ptr2) {
				return ptr1;
			}
			if (ptr1 == null) {
				ptr1 = headB;
			}
			if (ptr2 == null) {
				ptr2 = headA;
			}
		}
		return ptr1;
	}

	// Two Sum II - Input Array Is Sorted
	/*
	 * Given a 1-indexed array of integers numbers that is already sorted in
	 * non-decreasing order, find two numbers such that they add up to a specific
	 * target number. Let these two numbers be numbers[index1] and numbers[index2]
	 * where 1 <= index1 < index2 <= numbers.length.
	 * 
	 * Return the indices of the two numbers, index1 and index2, added by one as an
	 * integer array [index1, index2] of length 2.
	 * 
	 * The tests are generated such that there is exactly one solution. You may not
	 * use the same element twice.
	 */
	public int[] twoSumTwo(int[] numbers, int target) {
		int[] result = new int[2];
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			if (map.containsKey(target - numbers[i])) {
				result[1] = i + 1;
				result[0] = map.get(target - numbers[i]) + 1;
				return result;
			}
			map.put(numbers[i], i);
		}
		return result;
	}

	// Rotate array to the right
	public void rotate(int[] nums, int k) {
		if (nums == null || nums.length < 2) {
			return;
		}

		k = k % nums.length;
		reverse(nums, 0, nums.length - k - 1);
		reverse(nums, nums.length - k, nums.length - 1);
		reverse(nums, 0, nums.length - 1);
	}

	private void reverse(int[] nums, int i, int j) {
		int tmp = 0;
		while (i < j) {
			tmp = nums[i];
			nums[i] = nums[j];
			nums[j] = tmp;
			i++;
			j--;
		}
	}

	// Number of Islands
	/*
	 * Given an m x n 2D binary grid grid which represents a map of '1's (land) and
	 * '0's (water), return the number of islands.
	 * 
	 * An island is surrounded by water and is formed by connecting adjacent lands
	 * horizontally or vertically. You may assume all four edges of the grid are all
	 * surrounded by water.
	 * 
	 * 
	 * 
	 * Example 1:
	 * 
	 * Input: grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
	 * ["1","1","0","0","0"], ["0","0","0","0","0"] ] Output: 1
	 */
	public int numIslands(char[][] grid) {
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[0].length; j++) {
				if (grid[i][j] == '1') {
					dfsFill(grid, i, j);
					count++;
				}
			}
		}
		return count;
	}

	private void dfsFill(char[][] grid, int i, int j) {
		if (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == '1') {
			grid[i][j] = '0';
			dfsFill(grid, i + 1, j);
			dfsFill(grid, i - 1, j);
			dfsFill(grid, i, j + 1);
			dfsFill(grid, i, j - 1);
		}
	}

	// Happy Number
	/*
	 * Write an algorithm to determine if a number n is happy.
	 * 
	 * A happy number is a number defined by the following process:
	 * 
	 * Starting with any positive integer, replace the number by the sum of the
	 * squares of its digits. Repeat the process until the number equals 1 (where it
	 * will stay), or it loops endlessly in a cycle which does not include 1. Those
	 * numbers for which this process ends in 1 are happy. Return true if n is a
	 * happy number, and false if not.
	 */
	public boolean isHappy(int n) {
		Set<Integer> inLoop = new HashSet<Integer>();
		int squareSum, remain;
		while (inLoop.add(n)) {
			squareSum = 0;
			while (n > 0) {
				remain = n % 10;
				squareSum += remain * remain;
				n /= 10;
			}
			if (squareSum == 1)
				return true;
			else
				n = squareSum;

		}
		return false;
	}

	// Count primes less than N
	/*
	 * Given an integer n, return the number of prime numbers that are strictly less
	 * than n.
	 */
	public int countPrimes(int n) {
		if (n < 3)
			return 0;

		boolean[] f = new boolean[n];
		int count = n / 2;
		for (int i = 3; i * i < n; i += 2) {
			if (f[i])
				continue;

			for (int j = i * i; j < n; j += 2 * i) {
				if (!f[j]) {
					--count;
					f[j] = true;
				}
			}
		}
		return count;
	}

	// Reverse a linked list
	public ListNode reverseList(ListNode head) {
		ListNode prev = null;
		ListNode current = head;
		ListNode next = null;
		while (current != null) {
			next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		head = prev;
		return head;
	}

	// Word Search
	/*
	 * Given an m x n board of characters and a list of strings words, return all
	 * words on the board.
	 * 
	 * Each word must be constructed from letters of sequentially adjacent cells,
	 * where adjacent cells are horizontally or vertically neighboring. The same
	 * letter cell may not be used more than once in a word. Input: board =
	 * [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]],
	 * words = ["oath","pea","eat","rain"] Output: ["eat","oath"]
	 */
	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
		char c = board[i][j];
		if (c == '#' || p.next[c - 'a'] == null)
			return;
		p = p.next[c - 'a'];
		if (p.word != null) { // found one
			res.add(p.word);
			p.word = null; // de-duplicate
		}

		board[i][j] = '#';
		if (i > 0)
			dfs(board, i - 1, j, p, res);
		if (j > 0)
			dfs(board, i, j - 1, p, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, p, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, p, res);
		board[i][j] = c;
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	// Kth Largest Element in an Array
	/*
	 * Given an integer array nums and an integer k, return the kth largest element
	 * in the array.
	 * 
	 * Note that it is the kth largest element in the sorted order, not the kth
	 * distinct element.
	 */
	public int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(k + 1);
		for (int el : nums) {
			pq.add(el);
			if (pq.size() > k) {
				pq.poll();
			}
		}
		return pq.poll();
	}

	// Basic calculator
	/*
	 * Given a string s representing a valid expression, implement a basic
	 * calculator to evaluate it, and return the result of the evaluation.
	 * 
	 * Note: You are not allowed to use any built-in function which evaluates
	 * strings as mathematical expressions, such as eval().
	 */
	public int calculate(String s) {
		int len = s.length(), sign = 1, result = 0;
		Stack<Integer> stack = new Stack<Integer>();
		for (int i = 0; i < len; i++) {
			if (Character.isDigit(s.charAt(i))) {
				int sum = s.charAt(i) - '0';
				while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {
					sum = sum * 10 + s.charAt(i + 1) - '0';
					i++;
				}
				result += sum * sign;
			} else if (s.charAt(i) == '+')
				sign = 1;
			else if (s.charAt(i) == '-')
				sign = -1;
			else if (s.charAt(i) == '(') {
				stack.push(result);
				stack.push(sign);
				result = 0;
				sign = 1;
			} else if (s.charAt(i) == ')') {
				result = result * stack.pop() + stack.pop();
			}

		}
		return result;
	}

	public static void main(String[] args) {
		LeetCodeTest test = new LeetCodeTest();
		System.out.println(test.letterCombinations("23"));
		System.out.println(test.letterCombinations("2"));

		int[] nums = { 2, 7, 11, 15 };
		int[] result = test.twoSum(nums, 9);
		System.out.printf("%d %d%n", result[0], result[1]);

		int[] nums2 = { 3, 2, 4 };
		int[] result2 = test.twoSum(nums2, 6);
		System.out.printf("%d %d%n", result2[0], result2[1]);

		ListNode node1 = new ListNode(2);
		node1.next = new ListNode(4);
		node1.next.next = new ListNode(3);

		ListNode node2 = new ListNode(5);
		node2.next = new ListNode(6);
		node2.next.next = new ListNode(4);

		printLinkedList(test.addTwoNumbers(node1, node2));
		System.out.println();

		System.out.println(test.lengthOfLongestSubstring("abcabcbb"));

		int[] median1 = { 1, 3 };
		int[] median2 = { 2 };
		System.out.println(test.findMedianSortedArrays(median1, median2));

		System.out.println(test.longestPalindrome("babad"));
		System.out.println(test.longestPalindrome("cbbd"));

		System.out.println(test.convert("PAYPALISHIRING", 3));

		System.out.println(test.myAtoi("42"));
		System.out.println(test.myAtoi("-42"));
		System.out.println(test.myAtoi("  -42"));
		System.out.println(test.myAtoi("  +42"));
		System.out.println(test.myAtoi("4193 test"));
		System.out.println(test.myAtoi("4"));
		System.out.println(test.myAtoi(" "));
		System.out.println(test.myAtoi("  "));

		int[] sumArray = { -1, 0, 1, 2, -1, -4 };
		System.out.println(test.threeSum(sumArray));

		System.out.println(test.generateParenthesis(3));
		System.out.println(test.generateParenthesis(2));

		int[] height = { 0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1 };
		System.out.println(test.trap(height));
		int[] height2 = { 4, 2, 0, 3, 2, 5 };
		System.out.println(test.trap(height2));

		int[] permutate = { 1, 2, 3 };
		System.out.println(test.permute(permutate));
		int[] permutate2 = { 0, 1 };
		System.out.println(test.permute(permutate2));

		int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
		test.rotate(matrix);
		for (int[] matrixValues : matrix) {
			System.out.println(Arrays.toString(matrixValues));
		}

		String[] anagrams = { "eat", "tea", "tan", "ate", "nat", "bat" };
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));
		System.out.println(test.groupAnagrams(anagrams));

		int[][] intervals = { { 1, 3 }, { 2, 6 }, { 8, 10 }, { 15, 18 } };
		Arrays.stream(test.merge(intervals)).map(Arrays::toString).forEach(System.out::println);

		Arrays.stream(test.generateMatrix(3)).map(Arrays::toString).forEach(System.out::println);

		System.out.println(test.minPathSum(intervals));

		System.out.println(test.minDistance("horse", "ros"));
		System.out.println(test.minDistance("intention", "execution"));

		int[][] zeroMatrix = { { 1, 1, 1 }, { 1, 0, 1 }, { 1, 1, 0 }, { 1, 1, 1 } };
		test.setZeroes(zeroMatrix);
		Arrays.stream(zeroMatrix).map(Arrays::toString).forEach(System.out::println);

		int[] colors = { 2, 0, 2, 1, 1, 0 };
		test.sortColors(colors);
		System.out.println(Arrays.toString(colors));

		System.out.println(test.minWindow("ADOBECODEBANC", "ABC"));
		System.out.println(test.minWindow("a", "aa"));

		System.out.println(test.subsets(nums));

		System.out.println(test.grayCode(3));

		TreeNode node = new TreeNode(2, new TreeNode(1), new TreeNode(3));
		TreeNode node3 = new TreeNode(5);
		node3.left = new TreeNode(4);
		node3.right = new TreeNode(6);
		node3.right.left = new TreeNode(3);
		node3.right.right = new TreeNode(7);

		System.out.println(test.isValidBST(node));
		System.out.println(test.isValidBST(node3));

		System.out.println(test.getRow(0));
		System.out.println(test.getRow(1));
		System.out.println(test.getRow(3));
		System.out.println(test.getRow(5));
		System.out.println(test.getRow(4));

		int[] prices = { 7, 1, 5, 3, 6, 4 };
		System.out.println(test.maxProfit(prices));
		int[] prices2 = { 7, 6, 4, 3, 1 };
		System.out.println(test.maxProfit(prices2));

		System.out.println(test.sumNumbers(node3));

		System.out.println(test.wordBreak("leetcode", Arrays.asList("leet", "code")));
		System.out.println(test.wordBreak("applepenapple", Arrays.asList("apple", "pen")));
		System.out.println(test.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));

		int[] rotate = { 1, 2, 3, 4, 5, 6, 7 };
		test.rotate(rotate, 3);
		System.out.println(Arrays.toString(rotate));

		char[][] islands = { { '1', '1', '1', '1', '0' }, { '1', '1', '0', '1', '0' }, { '1', '1', '0', '0', '0' },
				{ '0', '0', '0', '0', '0' } };
		System.out.println(test.numIslands(islands));
		char[][] islands2 = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
				{ '0', '0', '0', '1', '1' } };
		System.out.println(test.numIslands(islands2));

		System.out.println(test.isHappy(19));
		System.out.println(test.isHappy(2));

		System.out.println(test.countPrimes(10));
		System.out.println(test.countPrimes(0));
		System.out.println(test.countPrimes(1));
		System.out.println(test.countPrimes(13));

		ListNode reverse = new ListNode(1);
		reverse.next = new ListNode(2);
		reverse.next.next = new ListNode(3);
		reverse.next.next.next = new ListNode(4);
		reverse.next.next.next.next = new ListNode(5);

		printLinkedList(reverse);
		System.out.println();
		printLinkedList(test.reverseList(reverse));
		System.out.println();

		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
				{ 'i', 'f', 'l', 'v' } };
		String[] words = { "oath", "pea", "eat", "rain" };
		System.out.println(test.findWords(board, words));

		int[] kthlargest = { 3, 2, 1, 5, 6, 4 };
		System.out.println(test.findKthLargest(kthlargest, 2));
		int[] kthlargest2 = { 3, 2, 3, 1, 2, 4, 5, 5, 6 };
		System.out.println(test.findKthLargest(kthlargest2, 4));

		System.out.println(test.calculate("1+1"));
		System.out.println(test.calculate("2-1"));
		System.out.println(test.calculate("2-1"));
		(1+(4+5+2)-3)+(6+8)

	}

	private static void printLinkedList(ListNode node) {
		if (node != null) {
			System.out.printf("%d ", node.val);
			printLinkedList(node.next);
		}
	}

}

class ListNode {
	int val;
	ListNode next;

	ListNode() {
	}

	ListNode(int val) {
		this.val = val;
		this.next = null;
	}

	ListNode(int val, ListNode next) {
		this.val = val;
		this.next = next;
	}
}

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode() {
	}

	TreeNode(int val) {
		this.val = val;
	}

	TreeNode(int val, TreeNode left, TreeNode right) {
		this.val = val;
		this.left = left;
		this.right = right;
	}
}

class Node {
	int val;
	Node next;
	Node random;

	public Node(int val) {
		this.val = val;
		this.next = null;
		this.random = null;
	}
}

class TrieNode {

	TrieNode[] next = new TrieNode[26];
	String word;

	boolean isWord;
	TrieNode[] c;

	public TrieNode() {
		isWord = false;
		c = new TrieNode[128];
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-22 17:09:26.139
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-22 17:09:26.143
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:439)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:366)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:326)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor40.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4881)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2022-02-02 12:24:43.694 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-02-02 12:25:06.451
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 2 0 2022-02-02 12:25:08.750
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.751
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-02 12:25:08.752
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-02-02 12:25:11.749
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-02 12:25:11.749
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@93c66ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e916dc2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-02 12:25:38.222
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-03 10:14:59.926 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.241
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.242
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.243
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.243
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.243
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.243
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.243
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-03 10:15:13.243
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-02-03 10:15:16.306
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-03 10:15:16.306
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@365a4b9b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@240e61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-03 10:15:35.818
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-07 11:03:30.483 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.723
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.724
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.725
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-07 11:03:53.725
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-02-07 11:03:55.827
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-07 11:03:55.827
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@61d4155b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@48590849,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-07 11:04:11.194
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-10 08:33:43.173 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.909
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.910
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.911
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.912
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.912
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-10 08:33:52.912
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-02-10 08:33:55.918
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 08:33:55.918
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e916dc2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a18e68a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-10 08:34:19.485
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-15 16:49:49.194 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.880
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-15 16:49:56.881
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-02-15 16:50:00.281
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 16:50:00.281
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7925e772,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@365a4b9b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-15 16:50:24.870
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-16 12:07:45.708 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.461
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.462
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-02-16 12:07:55.463
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-02-16 12:07:58.883
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 12:07:58.883
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44c54463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64b20d9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 12:08:26.160
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-04 15:25:22.655 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.core.resources 2 10035 2022-03-04 15:25:29.975
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.755
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.756
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.757
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.757
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.757
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.757
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.757
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-04 15:25:31.758
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-03-04 15:25:35.962
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-04 15:25:35.962
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f9e9c21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1390a43a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-04 15:26:03.272
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-22 19:49:29.546 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-03-22 19:49:45.949
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.949
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.949
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.949
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.950
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.951
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-22 19:49:45.952
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-03-22 19:49:48.527
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-22 19:49:48.527
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64b20d9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc3f1a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-22 19:50:14.341
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-24 14:56:33.520 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.816
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-03-24 14:56:46.817
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-03-24 14:56:48.827
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-24 14:56:48.827
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64b20d9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc3f1a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-24 14:57:06.623
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-04-05 08:02:19.438 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-04-05 08:02:26.935
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.935
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.935
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.935
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.935
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.935
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.936
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-05 08:02:26.937
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-04-05 08:02:29.567
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-05 08:02:29.567
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76efa2b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2027d56f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-05 08:02:50.264
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-04-05 08:23:53.279
!MESSAGE Internal Error
!STACK 1
Java Model Exception: javax.net.ssl.SSLException: Received fatal alert: internal_error
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:942)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1063)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:1021)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:519)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: javax.net.ssl.SSLException: Received fatal alert: internal_error
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:133)
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:117)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.Alert$AlertConsumer.consume(Alert.java:293)
	at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:185)
	at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:171)
	at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1475)
	at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1381)
	at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:441)
	at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:412)
	at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:567)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:171)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1600)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1528)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:308)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	... 9 more
Caused by: javax.net.ssl.SSLException: Received fatal alert: internal_error
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:133)
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:117)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.Alert$AlertConsumer.consume(Alert.java:293)
	at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:185)
	at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:171)
	at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1475)
	at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1381)
	at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:441)
	at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:412)
	at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:567)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:171)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1600)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1528)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:308)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1063)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:1021)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:519)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.jdt.core 4 985 2022-04-05 08:23:53.283
!MESSAGE Received fatal alert: internal_error
!STACK 0
javax.net.ssl.SSLException: Received fatal alert: internal_error
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:133)
	at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:117)
	at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:312)
	at java.base/sun.security.ssl.Alert$AlertConsumer.consume(Alert.java:293)
	at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:185)
	at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:171)
	at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1475)
	at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1381)
	at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:441)
	at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:412)
	at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:567)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:171)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1600)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1528)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:527)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:308)
	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:873)
	at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1063)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:1021)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:519)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.extractJavadoc(ProposalInfo.java:93)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.computeInfo(ProposalInfo.java:78)
	at org.eclipse.jdt.internal.ui.text.java.ProposalInfo.getInfo(ProposalInfo.java:63)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getAdditionalProposalInfo(AbstractJavaCompletionProposal.java:590)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$Timer$2$1.run(AdditionalInfoController.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.e4.ui.workbench 4 2 2022-04-13 08:10:42.143
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:534)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:237)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:266)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:98)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:72)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:990)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:963)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:942)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:897)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2095)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1726)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1722)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1760)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:579)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4761)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4860)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4860)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2022-04-13 08:10:42.155
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:534)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:237)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:266)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:98)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:72)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:990)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:963)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:942)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:897)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2095)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1726)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1722)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1760)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:579)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4761)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4860)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4860)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2022-04-14 18:32:30.806 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.272
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.273
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.274
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-14 18:32:37.274
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-04-14 18:32:39.350
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-14 18:32:39.350
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23169374,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f2b1a2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-04-14 18:32:55.518
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-01 04:54:19.541 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.569
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-01 04:54:31.570
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-05-01 04:54:33.964
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-01 04:54:33.964
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44c54463,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64b20d9c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-01 04:55:38.857
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-05-05 06:06:37.971 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-05-05 06:06:44.572
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.573
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.573
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.573
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.573
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.573
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.574
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.574
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.574
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.574
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.575
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.575
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.575
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.575
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.575
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.575
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-05-05 06:06:44.576
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-05-05 06:06:46.710
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-05-05 06:06:46.710
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc3f1a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7151dd9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-05-05 06:07:04.539
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-16 16:14:33.075 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-06-16 16:14:42.193
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.193
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.193
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.193
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.193
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.194
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-16 16:14:42.196
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-06-16 16:14:45.325
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-16 16:14:45.325
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46f041cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46baac0d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-16 16:15:07.819
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-24 16:05:12.514 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.782
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-06-24 16:05:22.783
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-06-24 16:05:26.566
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-24 16:05:26.566
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53202b06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44ba9f25,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-24 16:05:51.837
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-08-04 16:58:16.241 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-08-04 16:58:23.325
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.326
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-08-04 16:58:23.327
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-08-04 16:58:25.423
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-08-04 16:58:25.423
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@195888a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ced7cf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-08-04 16:58:46.176
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-11-08 09:19:45.447 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.886
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.887
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.887
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.887
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.888
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.890
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.890
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.891
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.892
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-11-08 09:19:54.893
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-11-08 09:19:58.117
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-08 09:19:58.117
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7151dd9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f596988,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-11-08 09:20:28.217
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 4 0 2022-11-08 09:20:42.415
!MESSAGE Execution exception for: ParameterizedCommand(Command(org.eclipse.ui.window.nextEditor,Next Editor,
		Switch to the next editor,
		Category(org.eclipse.ui.category.window,Window,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e655f9,
		,,true),null) in 
	context chain: WorkbenchContext -> TrimmedWindowImpl (IDEWindow) Context -> PerspectiveImpl (org.eclipse.jdt.ui.JavaPerspective) Context -> PartImpl (org.eclipse.e4.ui.compatibility.editor)  removeOnHide org.eclipse.jdt.ui.CompilationUnitEditor active activeOnClose (HashMapTest.java) Context
!STACK 0
org.eclipse.core.commands.ExecutionException: Error executing 'org.eclipse.ui.window.nextEditor': java.lang.NullPointerException
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:170)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1254)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Control.traverse(Control.java:4276)
	at org.eclipse.swt.widgets.Control.translateTraversal(Control.java:4258)
	at org.eclipse.swt.widgets.Composite.translateTraversal(Composite.java:1267)
	at org.eclipse.swt.widgets.Display.translateTraversal(Display.java:4832)
	at org.eclipse.swt.widgets.Display.filterMessage(Display.java:1272)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3608)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	... 41 more
Caused by: java.lang.NullPointerException
	at org.eclipse.swt.browser.IE.handleDOMEvent(IE.java:1686)
	at org.eclipse.swt.browser.IE.lambda$4(IE.java:360)
	at org.eclipse.swt.ole.win32.OleEventTable.sendEvent(OleEventTable.java:58)
	at org.eclipse.swt.ole.win32.OleEventSink.notifyListener(OleEventSink.java:160)
	at org.eclipse.swt.ole.win32.OleEventSink.Invoke(OleEventSink.java:128)
	at org.eclipse.swt.ole.win32.OleEventSink.access$1(OleEventSink.java:105)
	at org.eclipse.swt.ole.win32.OleEventSink$1.method6(OleEventSink.java:79)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:120)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceActiveObject.TranslateAccelerator(IOleInPlaceActiveObject.java:25)
	at org.eclipse.swt.ole.win32.OleFrame.translateOleAccelerator(OleFrame.java:798)
	at org.eclipse.swt.ole.win32.OleFrame.getMsgProc(OleFrame.java:224)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3607)
	at org.eclipse.ui.internal.FilteredTableBaseHandler.openDialog(FilteredTableBaseHandler.java:304)
	at org.eclipse.ui.internal.FilteredTableBaseHandler.execute(FilteredTableBaseHandler.java:131)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 45 more
!SESSION 2022-12-14 22:18:32.568 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=14.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.828
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-12-14 22:18:39.829
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2022-12-14 22:18:42.168
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-12-14 22:18:42.169
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@aaf4375,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f2a5064,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-12-14 22:19:01.059
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-11-08 15:27:54.927 -----------------------------------------------
eclipse.buildId=4.29.0.20230907-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.emf.ecore 2 0 2023-11-08 15:28:01.006
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY ch.qos.logback.classic 1 0 2023-11-08 15:28:01.251
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2023-11-08 15:28:29.066
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2023-11-08 15:28:33.840
!MESSAGE Logback config file: C:\Users\sakshaik\OneDrive - Capgemini\Sakib\practice\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.2.0.20230625-0847.xml

!ENTRY org.eclipse.jface 2 0 2023-11-08 15:28:52.623
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-08 15:28:52.623
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-08 15:29:17.314
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2023-11-08 15:29:17.435
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.search.SearchResultView" id and the "Classic Search" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2023-11-08 15:29:17.447
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.ui.views.ResourceNavigator" id and the "Navigator (Deprecated)" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled
!SESSION 2023-11-20 13:04:17.312 -----------------------------------------------
eclipse.buildId=4.29.0.20230907-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.emf.ecore 2 0 2023-11-20 13:04:25.643
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY ch.qos.logback.classic 1 0 2023-11-20 13:04:26.485
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2023-11-20 13:04:33.042
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2023-11-20 13:04:33.989
!MESSAGE Logback config file: C:\Users\sakshaik\OneDrive - Capgemini\Sakib\practice\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.2.0.20230625-0847.xml

!ENTRY org.eclipse.jface 2 0 2023-11-20 13:04:36.113
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 13:04:36.113
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-20 13:04:48.204
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-12-15 15:13:51.862 -----------------------------------------------
eclipse.buildId=4.29.0.20230907-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.emf.ecore 2 0 2023-12-15 15:14:00.382
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY ch.qos.logback.classic 1 0 2023-12-15 15:14:00.703
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 2 10035 2023-12-15 15:14:08.311
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY ch.qos.logback.classic 1 0 2023-12-15 15:14:09.456
!MESSAGE Logback config file: C:\Users\sakshaik\OneDrive - Capgemini\Sakib\practice\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.2.0.20230625-0847.xml

!ENTRY org.eclipse.jface 2 0 2023-12-15 15:14:11.561
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-15 15:14:11.561
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-15 15:14:20.197
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:19.490
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.codan.checkers,3.2.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:19.495
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt,9.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:19.502
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.codan.checkers.ui,3.2.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:19.509
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.codan.core,4.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:20.897
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.codan.core.cxx,3.4.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:20.953
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.codan.ui,3.2.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:21.049
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.codan.ui.cxx,3.3.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:21.106
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.core,6.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:21.191
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.core.native,5.9.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:22.075
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.core.win32,5.4.1.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:22.154
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.core.win32.x86_64,5.4.1.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:22.192
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.debug.core,8.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:22.359
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.debug.ui,8.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:22.672
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.doc.user,5.4.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:23.596
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.dsf,2.7.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:23.756
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.dsf.gdb,5.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:25.020
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.dsf.gdb.ui,2.6.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:25.292
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.dsf.ui,2.5.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:25.494
!MESSAGE No digest algorithm is available to verify download of org.eclipse.update.feature,org.eclipse.cdt.gnu.dsf,9.0.1.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:26.258
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.launch,9.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:26.366
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.make.core,7.3.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:26.632
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.make.ui,7.2.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:26.872
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.managedbuilder.core,8.4.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:27.012
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.managedbuilder.ui,9.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:27.757
!MESSAGE No digest algorithm is available to verify download of org.eclipse.update.feature,org.eclipse.cdt.native,9.0.1.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:28.277
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.native.serial,1.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:28.282
!MESSAGE No digest algorithm is available to verify download of org.eclipse.update.feature,org.eclipse.cdt.platform,9.0.1.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:28.450
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,org.eclipse.cdt.ui,6.0.0.201607151550.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:33.036
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,com.googlecode.goclipse.jvmcheck,1.0.0.v201607061938.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:33.039
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,com.googlecode.goclipse.debug,0.16.1.v201607061938.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:33.042
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,com.googlecode.goclipse.tooling,0.16.1.v201607061938.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:33.045
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,com.googlecode.goclipse.core,0.16.1.v201607061938.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:33.309
!MESSAGE No digest algorithm is available to verify download of osgi.bundle,com.googlecode.goclipse.ui,0.16.1.v201607061938.

!ENTRY org.eclipse.equinox.p2.artifact.repository 2 0 2023-12-15 15:17:33.314
!MESSAGE No digest algorithm is available to verify download of org.eclipse.update.feature,goclipse_feature,0.16.1.v201607061938.
!SESSION 2023-12-15 15:17:51.485 -----------------------------------------------
eclipse.buildId=4.29.0.20230907-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.emf.ecore 2 0 2023-12-15 15:19:59.558
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY ch.qos.logback.classic 1 0 2023-12-15 15:19:59.863
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.epp.mpc.core 4 0 2023-12-15 15:20:00.096
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core [353]
  Unresolved requirement: Import-Package: org.apache.hc.client5.http; version="[5.1.0,5.2.0)"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1852)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1845)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1786)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1750)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1672)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2023-12-15 15:20:00.100
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [354]
  Unresolved requirement: Import-Package: org.apache.hc.client5.http.auth; version="[5.1.0,5.2.0)"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1852)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1845)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1786)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1750)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1672)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.ui 4 0 2023-12-15 15:20:00.102
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.ui [356]
  Unresolved requirement: Require-Bundle: org.eclipse.epp.mpc.core; bundle-version="[1.10.1,2.0.0)"
    -> Bundle-SymbolicName: org.eclipse.epp.mpc.core; bundle-version="1.10.1.v20221110-1841"; singleton:="true"
       org.eclipse.epp.mpc.core [353]
         Unresolved requirement: Import-Package: org.apache.hc.client5.http; version="[5.1.0,5.2.0)"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1852)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1845)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1786)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1750)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1672)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY ch.qos.logback.classic 1 0 2023-12-15 15:20:06.924
!MESSAGE Logback config file: C:\Users\sakshaik\OneDrive - Capgemini\Sakib\practice\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.2.0.20230625-0847.xml

!ENTRY org.eclipse.jface 2 0 2023-12-15 15:20:09.567
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-15 15:20:09.567
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-15 15:20:09.567
!MESSAGE A conflict occurred for ALT+SHIFT+G:
Binding(ALT+SHIFT+G,
	ParameterizedCommand(Command(com.googlecode.goclipse.debug.ui.LaunchShortcut.run,Launch Go Application,
		Launch Go Application,
		Category(com.googlecode.goclipse.ui.commands.Category,Goclipse Category,Goclipse commands ,true),
		WorkbenchHandlerServiceHandler("com.googlecode.goclipse.debug.ui.LaunchShortcut.run"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+G,
	ParameterizedCommand(Command(org.eclipse.emf.codegen.ecore.ui.Generate,Generate Code,
		Generate code for the EMF models in the workspace,
		Category(org.eclipse.emf.codegen.ecore.ui.Commands,EMF Code Generation,Commands for the EMF code generation tools,true),
		WorkbenchHandlerServiceHandler("org.eclipse.emf.codegen.ecore.ui.Generate"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-15 15:20:30.216
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\sakshaik'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
